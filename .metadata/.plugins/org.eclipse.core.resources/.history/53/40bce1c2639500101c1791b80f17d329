#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"
#include "main.h"
#include "gpio.h"
#include "usart.h"
#include "adc.h"
#include "spi.h"
#include "i2c.h"
#include <string.h>
#include <stdio.h>
#include <stdint.h>

#define I2C_SLAVE_ADD 0x50

// SPI EEPROM Commands
#define SPI_CMD_READ_BYTE     0x01
#define SPI_CMD_WRITE_BYTE    0x02
#define SPI_CMD_READ_ALL      0x03
#define SPI_CMD_WRITE_ALL     0x04

// SPI Frame Format
#define SPI_CMD_HEADER        0x7E
#define SPI_CMD_TAIL          0x7F
#define SPI_RES_TRAIL         0xBB

// SPI Response IDs
#define SPI_RES_READ_BYTE     0x81
#define SPI_RES_WRITE_BYTE    0x82
#define SPI_RES_READ_ALL      0x83
#define SPI_RES_WRITE_ALL     0x84

#define SPI_TIMEOUT           1000
#define EEPROM_SIZE           1024

typedef enum
{
    MANUAL_MODE = 0,
    AUTOMATIC_MODE,
} Mode_Selection_t;
volatile Mode_Selection_t DefaultMode = MANUAL_MODE;

typedef enum {
    STATE_OFF = 0,
    STATE_IDLE,
    STATE_LOCKED,
    STATE_MOVING,
	STATE_ERROR
} SeatState_t;

volatile SeatState_t CurrentState = STATE_OFF;

typedef enum {
    SPI_IDLE = 0,
    SPI_READING,
    SPI_WRITING,
    SPI_ERROR
} SPI_State_t;

volatile SPI_State_t SPI_CurrentState = SPI_IDLE;

#pragma pack(push,1)
typedef struct
{
    uint16_t height;
    uint16_t slide;
    uint16_t incline;
    uint8_t command;
} SeatStatus_t;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
    uint8_t header;      // CMD_HEADER
    uint32_t length;     // Length
    uint8_t cmd_id;      // Command ID
    uint32_t param1;     // Parameter 1
    uint32_t param2;     // Parameter 2
    uint8_t tail;        // CMD_TAIL
} SPI_Command_t;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
    uint8_t header;      // CMD_HEADER
    uint32_t length;     // Length
    uint8_t res_id;      // Response ID
    uint32_t param1;     // Parameter 1
    uint8_t trail;       // RES_TRAIL
} SPI_Response_t;
#pragma pack(pop)

// Calibration data structure for EEPROM
#pragma pack(push,1)
typedef struct
{
    uint16_t height_offset;
    uint16_t height_coeff;
    uint16_t slide_offset;
    uint16_t slide_coeff;
    uint16_t incline_offset;
    uint16_t incline_coeff;
    uint16_t checksum;
} Calibration_Data_t;
#pragma pack(pop)

SeatStatus_t SeatST;
Calibration_Data_t CalibData;

volatile uint32_t Height_Variable  = 2;
volatile uint32_t Slide_Variable   = 3;
volatile uint32_t Incline_Variable = 67;

// Measured values after calibration
volatile uint32_t Height_Measured  = 0;
volatile uint32_t Slide_Measured   = 0;
volatile uint32_t Incline_Measured = 0;

// Physical values
volatile uint32_t Height_Physical  = 0;
volatile uint32_t Slide_Physical   = 0;
volatile uint32_t Incline_Physical = 0;

osThreadId_t SwitchModeHandle;
osThreadId_t AdcHeightHandle;
osThreadId_t AdcSlideHandle;
osThreadId_t AdcInclineHandle;
osThreadId_t Buttons_Read_Manual_mode_high;
osThreadId_t Buttons_Read_Manual_mode_Low;
osThreadId_t UART_TaskHandle;
osThreadId_t i2c_taskHandle;
osThreadId_t i2c_seatStatus_handle;
osThreadId_t fsmTaskHandle;
osThreadId_t spiEepromTaskHandle;
osThreadId_t calibrationTaskHandle;

osMessageQueueId_t UartQueueHandle;
osMessageQueueId_t SpiQueueHandle;

osMutexId_t i2cMutexHandle;
osMutexId_t spiMutexHandle;

const osThreadAttr_t switchmode_attributes = {
        .name = "SwitchModeTask",
        .stack_size = 128 * 4,
        .priority = (osPriority_t) osPriorityHigh,
};

const osThreadAttr_t adcHeight_attributes = {
        .name = "AdcHeightTask",
        .stack_size = 128 * 4,
        .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t adcSlide_attributes = {
        .name = "AdcSlideTask",
        .stack_size = 128 * 4,
        .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t adcIncline_attributes = {
        .name = "AdcInclineTask",
        .stack_size = 128 * 4,
        .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t Buttons_Attributes = {
        .name = "ButtonsHighAttrib",
        .stack_size = 128 * 4,
        .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t Button_attrib_low = {
        .name = "ButtonsLowAttrib",
        .stack_size = 128 * 4,
        .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t uartTask_attributes = {
        .name = "UARTTask",
        .stack_size = 128 * 4,
        .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t i2c_attributes = {
        .name = "i2cdef",
        .priority = (osPriority_t) osPriorityNormal,
        .stack_size = 128 * 4
};

const osThreadAttr_t i2c_statehandle = {
        .name = "i2cState",
        .priority = (osPriority_t) osPriorityBelowNormal,
        .stack_size =128 * 4
};

const osThreadAttr_t fsmTask_attributes = {
    .name = "FSM_Task",
    .stack_size = 128 * 4,
    .priority = (osPriority_t) osPriorityAboveNormal,
};

const osThreadAttr_t spiEeprom_attributes = {
    .name = "SPI_EEPROM_Task",
    .stack_size = 128 * 8,
    .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t calibration_attributes = {
    .name = "Calibration_Task",
    .stack_size = 128 * 4,
    .priority = (osPriority_t) osPriorityLow,
};

void SwitchModeTask(void *argument);
void AdcHeightTask(void *argument);
void AdcSlideTask(void *argument);
void AdcInclineTask(void *argument);
void Buttons_ReadTask_highmode(void *argument);
void Buttons_ReadTask_Lowmode(void *argument);
void UART_Task(void *argument);
void i2cTask(void *argument);
void i2_handle_seatstatus(void * argument);
void FSM_Task(void * argument);
void SPI_EEPROM_Task(void *argument);
void Calibration_Task(void *argument);

uint32_t Read_ADC_Channel(uint32_t channel);

// SPI EEPROM Functions
HAL_StatusTypeDef SPI_EEPROM_ReadByte(uint16_t address, uint8_t *data);
HAL_StatusTypeDef SPI_EEPROM_WriteByte(uint16_t address, uint8_t data);
HAL_StatusTypeDef SPI_EEPROM_ReadAll(uint8_t *buffer, uint16_t size);
HAL_StatusTypeDef SPI_EEPROM_WriteAll(uint8_t *buffer, uint16_t size);
void Calculate_Physical_Values(void);
uint16_t Calculate_Checksum(Calibration_Data_t *data);

void MX_FREERTOS_Init(void)
{
    UartQueueHandle = osMessageQueueNew(10, 50, NULL);
    SpiQueueHandle = osMessageQueueNew(5, sizeof(SPI_Command_t), NULL);

    const osMutexAttr_t i2cMutexAttr = { .name = "i2cMutex" };
    i2cMutexHandle = osMutexNew(&i2cMutexAttr);

    const osMutexAttr_t spiMutexAttr = { .name = "spiMutex" };
    spiMutexHandle = osMutexNew(&spiMutexAttr);

    SwitchModeHandle               = osThreadNew(SwitchModeTask, NULL, &switchmode_attributes);
    AdcHeightHandle                = osThreadNew(AdcHeightTask, NULL, &adcHeight_attributes);
    AdcSlideHandle                 = osThreadNew(AdcSlideTask,  NULL, &adcSlide_attributes);
    AdcInclineHandle               = osThreadNew(AdcInclineTask,NULL, &adcIncline_attributes);
    Buttons_Read_Manual_mode_high  = osThreadNew(Buttons_ReadTask_highmode, NULL, &Buttons_Attributes);
    Buttons_Read_Manual_mode_Low   = osThreadNew(Buttons_ReadTask_Lowmode, NULL, &Button_attrib_low);
    UART_TaskHandle                = osThreadNew(UART_Task, NULL, &uartTask_attributes);
    i2c_taskHandle                 = osThreadNew(i2cTask, NULL, &i2c_attributes);
    i2c_seatStatus_handle          = osThreadNew(i2_handle_seatstatus, NULL, &i2c_statehandle);
    fsmTaskHandle                  = osThreadNew(FSM_Task, NULL, &fsmTask_attributes);
    spiEepromTaskHandle            = osThreadNew(SPI_EEPROM_Task, NULL, &spiEeprom_attributes);
    calibrationTaskHandle          = osThreadNew(Calibration_Task, NULL, &calibration_attributes);
}

void UART_Task(void *argument)
{
    char msg[50];

    for(;;)
    {
        if (osMessageQueueGet(UartQueueHandle, msg, NULL, osWaitForever) == osOK)
        {
            msg[49] = '\0';
            HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        }
    }
}

void SPI_EEPROM_Task(void *argument)
{
    char msg[100];
    SPI_Command_t spi_cmd;
    uint8_t test_data;
    uint8_t buffer[32];

    osMessageQueuePut(UartQueueHandle, "SPI EEPROM Task Started\r\n", 0, 10);

    // Initialize default calibration values if EEPROM is empty
    CalibData.height_offset = 0;
    CalibData.height_coeff = 1000;  // 1.000 coefficient
    CalibData.slide_offset = 0;
    CalibData.slide_coeff = 1000;
    CalibData.incline_offset = 0;
    CalibData.incline_coeff = 1000;
    CalibData.checksum = Calculate_Checksum(&CalibData);

    for(;;)
    {
        switch(SPI_CurrentState)
        {
            case SPI_IDLE:
                // Test SPI communication every 5 seconds
                if(SPI_EEPROM_ReadByte(0x0000, &test_data) == HAL_OK)
                {
                    int len = snprintf(msg, sizeof(msg), "SPI Read Test: addr=0x0000, data=0x%02X\r\n", test_data);
                    if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
                }
                else
                {
                    osMessageQueuePut(UartQueueHandle, "SPI Read Test Failed\r\n", 0, 10);
                }
                break;

            case SPI_READING:
                // Handle read operations
                osMessageQueuePut(UartQueueHandle, "SPI Reading...\r\n", 0, 10);
                SPI_CurrentState = SPI_IDLE;
                break;

            case SPI_WRITING:
                // Handle write operations
                osMessageQueuePut(UartQueueHandle, "SPI Writing...\r\n", 0, 10);
                SPI_CurrentState = SPI_IDLE;
                break;

            case SPI_ERROR:
                osMessageQueuePut(UartQueueHandle, "SPI Error State\r\n", 0, 10);
                SPI_CurrentState = SPI_IDLE;
                break;
        }

        osDelay(5000); // 5 second cycle
    }
}

void Calibration_Task(void *argument)
{
    char msg[100];
    uint8_t calib_buffer[sizeof(Calibration_Data_t)];

    osMessageQueuePut(UartQueueHandle, "Calibration Task Started\r\n", 0, 10);

    for(;;)
    {
        // Try to read calibration data from EEPROM
        if(SPI_EEPROM_ReadAll(calib_buffer, sizeof(Calibration_Data_t)) == HAL_OK)
        {
            // Copy data and verify checksum
            memcpy(&CalibData, calib_buffer, sizeof(Calibration_Data_t));

            if(CalibData.checksum == Calculate_Checksum(&CalibData))
            {
                int len = snprintf(msg, sizeof(msg), "Calib Data Valid: H_coeff=%u, S_coeff=%u, I_coeff=%u\r\n",
                    CalibData.height_coeff, CalibData.slide_coeff, CalibData.incline_coeff);
                if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
            }
            else
            {
                osMessageQueuePut(UartQueueHandle, "Calib Data Checksum Invalid\r\n", 0, 10);
                // Use default values
                CalibData.height_coeff = 1000;
                CalibData.slide_coeff = 1000;
                CalibData.incline_coeff = 1000;
            }
        }
        else
        {
            osMessageQueuePut(UartQueueHandle, "Failed to read calibration data\r\n", 0, 10);
        }

        // Calculate physical values using calibration data
        Calculate_Physical_Values();

        osDelay(10000); // 10 second cycle for calibration updates
    }
}

void Calculate_Physical_Values(void)
{
    // Apply calibration to convert raw ADC values to physical values
    Height_Measured = (Height_Variable * CalibData.height_coeff) / 1000 + CalibData.height_offset;
    Slide_Measured = (Slide_Variable * CalibData.slide_coeff) / 1000 + CalibData.slide_offset;
    Incline_Measured = (Incline_Variable * CalibData.incline_coeff) / 1000 + CalibData.incline_offset;

    // Keep values within valid ranges
    if(Height_Measured < 20) Height_Physical = 20;        // 2.0 cm minimum
    else if(Height_Measured > 53) Height_Physical = 53;   // 5.3 cm maximum
    else Height_Physical = Height_Measured;

    if(Slide_Measured < 30) Slide_Physical = 30;          // 3.0 cm minimum
    else if(Slide_Measured > 75) Slide_Physical = 75;     // 7.5 cm maximum
    else Slide_Physical = Slide_Measured;

    if(Incline_Measured < 6753) Incline_Physical = 6753;  // 67°5'30" minimum
    else if(Incline_Measured > 10553) Incline_Physical = 10553; // 105°5'30" maximum
    else Incline_Physical = Incline_Measured;
}

uint16_t Calculate_Checksum(Calibration_Data_t *data)
{
    uint16_t checksum = 0;
    uint8_t ptr = (uint8_t)data;

    // Calculate checksum excluding the checksum field itself
    for(int i = 0; i < sizeof(Calibration_Data_t) - sizeof(uint16_t); i++)
    {
//        checksum += ptr[i];
    }

    return checksum;
}

HAL_StatusTypeDef SPI_EEPROM_ReadByte(uint16_t address, uint8_t *data)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT) == osOK)
    {
        SPI_Command_t cmd;
        SPI_Response_t response;
        uint8_t tx_buffer[sizeof(SPI_Command_t)];
        uint8_t rx_buffer[sizeof(SPI_Response_t)];

        // Prepare command
        cmd.header = SPI_CMD_HEADER;
        cmd.length = sizeof(SPI_Command_t);
        cmd.cmd_id = SPI_CMD_READ_BYTE;
        cmd.param1 = address;
        cmd.param2 = 0;
        cmd.tail = SPI_CMD_TAIL;

        memcpy(tx_buffer, &cmd, sizeof(SPI_Command_t));

        // Send command and receive response
        if(HAL_SPI_TransmitReceive(&hspi2, tx_buffer, rx_buffer, sizeof(SPI_Command_t), SPI_TIMEOUT) == HAL_OK)
        {
            // Parse response
            memcpy(&response, rx_buffer, sizeof(SPI_Response_t));

            if(response.header == SPI_CMD_HEADER &&
               response.res_id == SPI_RES_READ_BYTE &&
               response.trail == SPI_RES_TRAIL)
            {
                *data = (uint8_t)(response.param1 & 0xFF);
                result = HAL_OK;
            }
        }

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

HAL_StatusTypeDef SPI_EEPROM_WriteByte(uint16_t address, uint8_t data)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT) == osOK)
    {
        SPI_Command_t cmd;
        SPI_Response_t response;
        uint8_t tx_buffer[sizeof(SPI_Command_t)];
        uint8_t rx_buffer[sizeof(SPI_Response_t)];

        // Prepare command
        cmd.header = SPI_CMD_HEADER;
        cmd.length = sizeof(SPI_Command_t);
        cmd.cmd_id = SPI_CMD_WRITE_BYTE;
        cmd.param1 = address;
        cmd.param2 = data;
        cmd.tail = SPI_CMD_TAIL;

        memcpy(tx_buffer, &cmd, sizeof(SPI_Command_t));

        // Send command and receive response
        if(HAL_SPI_TransmitReceive(&hspi2, tx_buffer, rx_buffer, sizeof(SPI_Command_t), SPI_TIMEOUT) == HAL_OK)
        {
            // Parse response
            memcpy(&response, rx_buffer, sizeof(SPI_Response_t));

            if(response.header == SPI_CMD_HEADER &&
               response.res_id == SPI_RES_WRITE_BYTE &&
               response.trail == SPI_RES_TRAIL &&
               response.param1 == 1) // OK response
            {
                result = HAL_OK;
            }
        }

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

HAL_StatusTypeDef SPI_EEPROM_ReadAll(uint8_t *buffer, uint16_t size)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT * 2) == osOK)
    {
        SPI_Command_t cmd;
        uint8_t tx_buffer[sizeof(SPI_Command_t)];
        uint8_t rx_buffer[EEPROM_SIZE + 20]; // Extra space for response header

        // Prepare command
        cmd.header = SPI_CMD_HEADER;
        cmd.length = sizeof(SPI_Command_t);
        cmd.cmd_id = SPI_CMD_READ_ALL;
        cmd.param1 = size;
        cmd.param2 = 0;
        cmd.tail = SPI_CMD_TAIL;

        memcpy(tx_buffer, &cmd, sizeof(SPI_Command_t));

        // Send command
        if(HAL_SPI_Transmit(&hspi2, tx_buffer, sizeof(SPI_Command_t), SPI_TIMEOUT) == HAL_OK)
        {
            osDelay(10); // Small delay for EEPROM to process

            // Receive response
            if(HAL_SPI_Receive(&hspi2, rx_buffer, size + 10, SPI_TIMEOUT * 2) == HAL_OK)
            {
                // Parse response and extract data
                if(rx_buffer[0] == SPI_CMD_HEADER && rx_buffer[5] == SPI_RES_READ_ALL)
                {
                    memcpy(buffer, &rx_buffer[10], size); // Skip header
                    result = HAL_OK;
                }
            }
        }

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

HAL_StatusTypeDef SPI_EEPROM_WriteAll(uint8_t *buffer, uint16_t size)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT * 3) == osOK)
    {
        SPI_Command_t cmd;
        uint8_t tx_buffer[sizeof(SPI_Command_t) + EEPROM_SIZE];
        uint8_t rx_buffer[sizeof(SPI_Response_t)];

        // Prepare command
        cmd.header = SPI_CMD_HEADER;
        cmd.length = sizeof(SPI_Command_t) + size;
        cmd.cmd_id = SPI_CMD_WRITE_ALL;
        cmd.param1 = size;
        cmd.param2 = 0;
        cmd.tail = SPI_CMD_TAIL;

        memcpy(tx_buffer, &cmd, sizeof(SPI_Command_t));
        memcpy(&tx_buffer[sizeof(SPI_Command_t)], buffer, size);

        // Send command and data
        if(HAL_SPI_Transmit(&hspi2, tx_buffer, sizeof(SPI_Command_t) + size, SPI_TIMEOUT * 2) == HAL_OK)
        {
            osDelay(50); // Delay for write operation

            // Receive response
            if(HAL_SPI_Receive(&hspi2, rx_buffer, sizeof(SPI_Response_t), SPI_TIMEOUT) == HAL_OK)
            {
                SPI_Response_t response;
                memcpy(&response, rx_buffer, sizeof(SPI_Response_t));

                if(response.header == SPI_CMD_HEADER &&
                   response.res_id == SPI_RES_WRITE_ALL &&
                   response.trail == SPI_RES_TRAIL &&
                   response.param1 == 1) // OK response
                {
                    result = HAL_OK;
                }
            }
        }

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

void i2_handle_seatstatus(void * argument)
{
    char uart_msg_ok[]  = "I2C message sent \r\n";
    char uart_msg_nok[] = "I2C message not sent\r\n";
    char errbuf[64];

    uint8_t txBuffer[sizeof(SeatST)];

    for(;;)
    {
        // Use physical values instead of raw variables
        SeatST.height   = (uint16_t)Height_Physical;
        SeatST.slide    = (uint16_t)Slide_Physical;
        SeatST.incline  = (uint16_t)Incline_Physical;

        if(DefaultMode == MANUAL_MODE)
        {
        	SeatST.command ='M';
        }else if(DefaultMode == AUTOMATIC_MODE)
        {
        	SeatST.command = 'A';
        }

        memcpy(txBuffer, &SeatST, sizeof(SeatST));

        if (osMutexAcquire(i2cMutexHandle, 200) == osOK)
        {
            HAL_StatusTypeDef res = HAL_I2C_Master_Transmit(&hi2c1,
                                                            (uint16_t)(I2C_SLAVE_ADD << 1),
                                                            txBuffer,
                                                            sizeof(txBuffer),
                                                            200);

            osMutexRelease(i2cMutexHandle);

            if (res == HAL_OK)
            {
                osMessageQueuePut(UartQueueHandle, uart_msg_ok, 0, 10);
            }
            else
            {
                int len = snprintf(errbuf, sizeof(errbuf), "I2C error =%d\r\n", (int)res);
                if(len>0) osMessageQueuePut(UartQueueHandle, errbuf, 0, 10);
                osMessageQueuePut(UartQueueHandle, uart_msg_nok, 0, 10);
            }
        }
        else
        {
            osMessageQueuePut(UartQueueHandle, uart_msg_nok, 0, 10);
        }
        osDelay(1500);
    }
}

void i2cTask(void *argument)
{
    uint8_t tx;
    char uart_msg_ok[]  = "I2C mode sent \r\n";
    char uart_msg_err[] = "I2C mode error\r\n";
    char errbuf[64];

    for(;;)
    {
        tx = (DefaultMode == AUTOMATIC_MODE) ? 'A' : 'M';

        if (osMutexAcquire(i2cMutexHandle, 200) == osOK)
        {
            HAL_StatusTypeDef res = HAL_I2C_Master_Transmit(&hi2c1,
                                                            (uint16_t)(I2C_SLAVE_ADD << 1),
                                                            &tx,
                                                            1,
                                                            200);
            osMutexRelease(i2cMutexHandle);

            if (res == HAL_OK)
            {
                osMessageQueuePut(UartQueueHandle, uart_msg_ok, 0, 10);
            }
            else
            {
                int len = snprintf(errbuf, sizeof(errbuf), "I2C mode error =%d\r\n", (int)res);
                if(len>0) osMessageQueuePut(UartQueueHandle, errbuf, 0, 10);
                osMessageQueuePut(UartQueueHandle, uart_msg_err, 0, 10);
            }
        }
        else
        {
            osMessageQueuePut(UartQueueHandle, uart_msg_err, 0, 10);
        }

        osDelay(1000);
    }
}

void SwitchModeTask(void *argument)
{
    char msg_auto[]   = "Switched to AUTO mode\r\n";
    char msg_manual[] = "Switched to MANUAL mode\r\n";

    for(;;)
    {
        if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET)
        {
            taskENTER_CRITICAL();
            DefaultMode = (DefaultMode == MANUAL_MODE) ? AUTOMATIC_MODE : MANUAL_MODE;
            taskEXIT_CRITICAL();

            if(DefaultMode == AUTOMATIC_MODE)
                osMessageQueuePut(UartQueueHandle, msg_auto, 0, 10);
            else
                osMessageQueuePut(UartQueueHandle, msg_manual, 0, 10);

            while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) {
                osDelay(10);
            }
        }
        osDelay(50);
    }
}

void AdcHeightTask(void *argument)
{
    char msg[50];

    for(;;)
    {
        if(DefaultMode == AUTOMATIC_MODE)
        {
            uint32_t value = Read_ADC_Channel(ADC_CHANNEL_11);

            taskENTER_CRITICAL();
            Height_Variable = value;
            taskEXIT_CRITICAL();

            int len = snprintf(msg, sizeof(msg), "Height_raw=%lu, phys=%lu\r\n", value, Height_Physical);
            if (len > 0) {
                osMessageQueuePut(UartQueueHandle, msg, 0, 10);
            }
        }
        osDelay(200);
    }
}

void AdcSlideTask(void *argument)
{
    char msg[50];

    for(;;)
    {
        if(DefaultMode == AUTOMATIC_MODE)
        {
            uint32_t value = Read_ADC_Channel(ADC_CHANNEL_12);

            taskENTER_CRITICAL();
            Slide_Variable = value;
            taskEXIT_CRITICAL();

            int len = snprintf(msg, sizeof(msg), "Slide_raw=%lu, phys=%lu\r\n", value, Slide_Physical);
            if (len > 0) {
                osMessageQueuePut(UartQueueHandle, msg, 0, 10);
            }
        }
        osDelay(250);
    }
}

void AdcInclineTask(void *argument)
{
    char msg[50];

    for(;;)
    {
        if(DefaultMode == AUTOMATIC_MODE)
        {
            uint32_t value = Read_ADC_Channel(ADC_CHANNEL_13);

            taskENTER_CRITICAL();
            Incline_Variable = value;
            taskEXIT_CRITICAL();

            int len = snprintf(msg, sizeof(msg), "Incline_raw=%lu, phys=%lu\r\n", value, Incline_Physical);
            if (len > 0) {
                osMessageQueuePut(UartQueueHandle, msg, 0, 10);
            }
        }
        osDelay(300);
    }
}

void Buttons_ReadTask_highmode(void * argument)
{
    char msg1[] = "Height Increasing\r\n";
    char msg2[] = "Slider Increasing\r\n";
    char incline_inc[] = "Incline Increase\r\n";
    char incline_inc_max[] = "Incline Increase Max\r\n";
    char msg3[] = "Maximum Height\r\n";
    char msg4[] = "Maximum Slider\r\n";

    for(;;)
    {
        if(DefaultMode == MANUAL_MODE)
        {
            if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Height_Variable >= 5)
                {
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, msg3, 0, 10);
                }
                else
                {
                    Height_Variable += 1;
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, msg1, 0, 10);
                }
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Slide_Variable >= 7)
                {
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, msg4, 0, 10);
                }
                else
                {
                    Slide_Variable += 1;
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, msg2, 0, 10);
                }
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Incline_Variable >= 105)
                {
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, incline_inc_max, 0, 10);
                }
                else
                {
                    Incline_Variable += 1;
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, incline_inc, 0, 10);
                }
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7) == GPIO_PIN_SET) osDelay(10);
            }

            osDelay(50);
        }
        else
        {
            osDelay(100);
        }
    }
}

void Buttons_ReadTask_Lowmode(void * argument)
{
    char Notification_height_dec[] = "Height Decrease\r\n";
    char Notification_height_maxdec[] = "Height Decrease Max\r\n";

    char Notification_slide_dec[] = "Slide Decrease\r\n";
    char Notification_slide_maxdec[] = "Slide Decrease Max\r\n";

    char Notification_incline_dec[] = "Incline Decrease\r\n";
    char Notification_incline_maxdec[] = "Incline Decrease Max\r\n";

    for(;;)
    {
        if (DefaultMode == MANUAL_MODE)
        {
            if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_4) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Height_Variable <= 2)
                {
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, Notification_height_maxdec, 0, 10);
                }
                else
                {
                    Height_Variable -= 1;
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, Notification_height_dec, 0, 10);
                }
                while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_4) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_5) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Slide_Variable <= 3)
                {
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, Notification_slide_maxdec, 0, 10);
                }
                else
                {
                    Slide_Variable -= 1;
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, Notification_slide_dec, 0, 10);
                }
                while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_5) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Incline_Variable <= 67)
                {
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, Notification_incline_maxdec, 0, 10);
                }
                else
                {
                    Incline_Variable -= 1;
                    taskEXIT_CRITICAL();
                    osMessageQueuePut(UartQueueHandle, Notification_incline_dec, 0, 10);
                }
                while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET) osDelay(10);
            }

            osDelay(50);
        }
        else
        {
            osDelay(100);
        }
    }
}

uint32_t Read_ADC_Channel(uint32_t channel)
{
    ADC_ChannelConfTypeDef sConfig = {0};

    sConfig.Channel = channel;
    sConfig.Rank = 1;
    sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;

    HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    uint32_t value = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);

    return value;
}

// ==== FSM Task ====
void FSM_Task(void *argument)
{
//    char msg[50];

    for(;;)
    {
    	switch(CurrentState)
    	{
    	    case STATE_OFF:
    	        osMessageQueuePut(UartQueueHandle, "State=OFF\r\n", 0, 10);
    	        if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_1) == GPIO_PIN_SET) // Ignition
    	        {
    	            CurrentState = STATE_IDLE;
    	            // Initialize SPI EEPROM communication when turning on
    	            SPI_CurrentState = SPI_IDLE;
    	        }
    	        break;

    	    case STATE_IDLE:
    	        osMessageQueuePut(UartQueueHandle, "State=IDLE\r\n", 0, 10);
    	        if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) // Start Moving
    	            CurrentState = STATE_MOVING;
    	        else if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_SET) // Lock
    	            CurrentState = STATE_LOCKED;
    	        break;

    	    case STATE_MOVING:
    	        osMessageQueuePut(UartQueueHandle, "State=MOVING\r\n", 0, 10);
    	        if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET) // Stop
    	            CurrentState = STATE_IDLE;
    	        // Check for error conditions using physical values
    	        else if (Height_Physical > 53 || Slide_Physical > 75 || Incline_Physical > 10553)
    	        {
    	            CurrentState = STATE_ERROR;
    	            SPI_CurrentState = SPI_ERROR;
    	        }
    	        break;

    	    case STATE_LOCKED:
    	        osMessageQueuePut(UartQueueHandle, "State=LOCKED\r\n", 0, 10);
    	        if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_2) == GPIO_PIN_SET) // Unlock
    	            CurrentState = STATE_IDLE;
    	        break;

    	    case STATE_ERROR:
    	        osMessageQueuePut(UartQueueHandle, "⚠ ERROR STATE - SPI/Sensor Error\r\n", 0, 10);
    	        // In error state:
    	        // 1. Stop all movements
    	        // 2. Try to save current state to EEPROM
    	        // 3. Wait for reset
    	        if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_8) == GPIO_PIN_SET) // Reset button
    	        {
    	            CurrentState = STATE_IDLE;
    	            SPI_CurrentState = SPI_IDLE;

    	            // Try to save calibration data on reset
    	            uint8_t calib_buffer[sizeof(Calibration_Data_t)];
    	            CalibData.checksum = Calculate_Checksum(&CalibData);
    	            memcpy(calib_buffer, &CalibData, sizeof(Calibration_Data_t));

    	            if(SPI_EEPROM_WriteAll(calib_buffer, sizeof(Calibration_Data_t)) == HAL_OK)
    	            {
    	                osMessageQueuePut(UartQueueHandle, "Calibration saved to EEPROM\r\n", 0, 10);
    	            }
    	        }
    	        break;
    	}

        osDelay(300);
    }
}
