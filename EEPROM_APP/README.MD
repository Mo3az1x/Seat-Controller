# EEPROM Programmer & Memory Management System

A comprehensive dual-interface EEPROM programming and memory management system featuring Arduino firmware with UART/SPI communication protocols and a Java-based GUI for advanced memory operations.

## ğŸ¯ Overview

This project provides a complete solution for EEPROM memory management with:
- *Arduino-based EEPROM emulator* with dual communication protocols (UART + SPI)
- *Java GUI application* for memory operations and real-time monitoring
- *Memory service architecture* with structured data regions
- *Protocol sniffing and debugging* capabilities
- *Real-time trace logging* for development and diagnostics

## ğŸ— System Architecture


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    UART/SPI    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Java GUI Client  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Arduino EEPROM     â”‚
â”‚                     â”‚                â”‚  Emulator           â”‚
â”‚ â€¢ Memory Operations â”‚                â”‚ â€¢ UART Protocol     â”‚
â”‚ â€¢ Trace Logging     â”‚                â”‚ â€¢ SPI Slave Mode    â”‚
â”‚ â€¢ Memory Services   â”‚                â”‚ â€¢ Memory Regions    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


### Memory Layout

| Region | Address Range | Purpose | Description |
|--------|---------------|---------|-------------|
| *Startup* | 0x0000 - 0x0003 | Boot Configuration | System initialization parameters |
| *Calibration* | 0x0004 - 0x03FF | Calibration Data | Sensor calibration and configuration |
| *Diagnostic* | 0x0400 - 0x07FF | Diagnostic Info | Error logs and system diagnostics |

## ğŸ“ Project Structure


EEPROM_APP/
â”œâ”€â”€ eeprom/
â”‚   â”œâ”€â”€ eeprom.ino              # Arduino firmware (UART + SPI)
â”‚   â””â”€â”€ NvmManager.java         # Memory manager utility class
â”œâ”€â”€ src/eeprom/eeprom/
â”‚   â”œâ”€â”€ EepromGUI.java          # Main GUI application
â”‚   â”œâ”€â”€ PortUtil.java           # Serial port utilities
â”‚   â”œâ”€â”€ SerialComm.java         # Serial communication handler
â”‚   â”œâ”€â”€ SnifferManager.java     # Protocol sniffer and analyzer
â”‚   â””â”€â”€ TraceListener.java      # Trace logging interface
â””â”€â”€ README.md                   # This file


## âš¡ Features

### Arduino Firmware (eeprom.ino)

#### Communication Protocols
- *UART Protocol*: Frame-based communication with header/tail markers
- *SPI Slave Mode*: Direct memory access for high-speed operations
- *Dual-mode operation*: Both protocols can be used simultaneously

#### Command Set
| Command | ID | Description |
|---------|----|-----------| 
| CMD_READ_BYTE | 0x01 | Read single byte from address |
| CMD_WRITE_BYTE | 0x02 | Write single byte to address |
| CMD_READ_ALL | 0x03 | Read entire memory or specified range |
| CMD_WRITE_ALL | 0x04 | Write data block to memory |
| CMD_CLEAR | 0x05 | Clear entire EEPROM (fill with 0xFF) |
| CMD_VERIFY | 0x06 | Verify written data integrity |
| CMD_STARTUP | 0x07 | Get system information |
| CMD_DIAGNOSIS | 0x08 | Get diagnostic information |
| CMD_CALIB_READ | 0x0A | Read calibration data |
| CMD_CALIB_WRITE | 0x0B | Write calibration data |

#### Frame Format (UART)


â”‚ 0x7E â”‚ LENGTH(4B) â”‚ CMD(1B) â”‚ DATA â”‚ 0x7F â”‚
â”‚Headerâ”‚   32-bit   â”‚ Command â”‚      â”‚ Tail â”‚


### Java GUI Application

#### Main Features
- *Tabbed Interface*: Organized by functionality (EEPROM, Utility, Memory Service)
- *Real-time Communication*: Live trace logging of all operations
- *Memory Services*: Structured access to memory regions
- *Protocol Sniffing*: Advanced debugging and analysis tools

#### GUI Tabs

##### 1. EEPROM Operations
- *Read Byte*: Read single memory location
- *Write Byte*: Write single byte to specific address
- *Read All*: Dump entire memory or specified range
- *Write All*: Bulk write operations

##### 2. Utility Functions
- *Clear*: Erase entire EEPROM
- *Verify*: Data integrity checking

##### 3. Memory Service
- *Startup Region*: Boot configuration management
- *Calibration Region*: Sensor calibration data
- *Diagnostic Region*: System diagnostic information

## ğŸš€ Getting Started

### Prerequisites

#### Hardware
- *Arduino Uno/Nano* (or compatible)
- *USB cable* for programming and communication
- *Optional*: SPI master device (e.g., STM32) for SPI testing

#### Software
- *Arduino IDE* (1.8.x or newer)
- *Java Runtime Environment* (JRE 8 or newer)
- *Java Development Kit* (JDK 8 or newer) for compilation
- *jSerialComm library* for Java serial communication

### Installation

#### 1. Arduino Setup
bash
# Upload the firmware to Arduino
# Open eeprom/eeprom.ino in Arduino IDE
# Select your board and port
# Click Upload


#### 2. Java Dependencies
Add jSerialComm to your project:
xml
<!-- Maven -->
<dependency>
    <groupId>com.fazecast</groupId>
    <artifactId>jSerialComm</artifactId>
    <version>2.9.2</version>
</dependency>


#### 3. Compile Java Application
bash
# Navigate to src directory
cd EEPROM_APP/src

# Compile (ensure jSerialComm.jar is in classpath)
javac -cp ".:jSerialComm.jar" eeprom/*.java

# Run the GUI
java -cp ".:jSerialComm.jar" eeprom.EepromGUI


### Basic Usage

#### 1. Connect Hardware
1. Upload Arduino firmware
2. Connect Arduino to PC via USB
3. Note the COM port (e.g., COM3, /dev/ttyUSB0)

#### 2. Launch GUI Application
1. Run the Java GUI application
2. Select the correct COM port from dropdown
3. Set baud rate to *9600*
4. Click *Connect*

#### 3. Perform Operations

Example Workflow:
1. Click "Write Byte" â†’ Enter address: 100 â†’ Enter value: 42
2. Click "Read Byte" â†’ Enter address: 100 â†’ Verify value is 42
3. Check trace log for communication details


## ğŸ”§ Protocol Details

### UART Communication

#### Request Frame Structure
c
byte frame[] = {
    0x7E,           // Header
    0x00, 0x00, 0x00, 0x05,  // Length (5 bytes)
    CMD_READ_BYTE,  // Command
    0x00, 0x00, 0x00, 0x64,  // Address (100)
    0x00,           // Value (for write operations)
    0x7F            // Tail
};


#### Response Frame Structure
c
byte response[] = {
    0x7E,           // Header
    0x00, 0x00, 0x00, 0x01,  // Length (1 byte)
    RES_READ_BYTE,  // Response type
    0x2A,           // Data (value 42)
    0x7F            // Tail
};


### SPI Communication

#### SPI Command Sequence

1. Master sends: CMD_READ (0x03)
2. Master sends: Address High Byte
3. Master sends: Address Low Byte
4. Master receives: Data byte


## ğŸ“Š Memory Services

### NvmManager Class Usage
java
NvmManager nvm = new NvmManager();

// Read operations
String startup = nvm.readStartup();
String calib = nvm.readCalibration();
String diag = nvm.readDiagnostic();

// Write operations
byte[] startupData = {0x01, 0x02, 0x03, 0x04};
String result = nvm.writeStartup(startupData);


## ğŸ› Debugging & Troubleshooting

### Common Issues

#### Connection Problems

Symptoms: "Failed to connect" message
Solutions:
â€¢ Check COM port selection
â€¢ Verify Arduino is plugged in
â€¢ Ensure correct baud rate (9600)
â€¢ Close other serial applications


#### Communication Errors

Symptoms: No response from Arduino
Solutions:
â€¢ Check Arduino serial monitor for error messages
â€¢ Verify frame format in trace log
â€¢ Reset Arduino and reconnect
â€¢ Check USB cable integrity


#### Memory Operation Failures

Symptoms: NACK responses or verification failures
Solutions:
â€¢ Check address range limits
â€¢ Verify data format
â€¢ Monitor for error flags in diagnostic
â€¢ Check EEPROM wear level


### Trace Log Analysis

Example trace output:
Operation: READ_BYTE | Addr=100
Frame: 7E 00 00 00 05 01 00 00 00 64 00 7F
Received: 7E 00 00 00 01 81 2A 7F

Analysis:
â€¢ 7E/7F = Header/Tail markers âœ“
â€¢ 05 = Command payload length âœ“  
â€¢ 01 = READ_BYTE command âœ“
â€¢ 64 = Address 100 (0x64) âœ“
â€¢ 81 = READ_BYTE response âœ“
â€¢ 2A = Data value 42 (0x2A) âœ“


## ğŸ”’ Safety Features

### Error Handling
- *Address validation*: Prevents out-of-bounds access
- *Frame integrity*: Header/tail validation
- *Timeout protection*: Prevents hanging operations
- *Error reporting*: Comprehensive diagnostic feedback

### Data Protection
- *Verification commands*: Ensure write operations succeeded
- *Memory region isolation*: Separate startup, calibration, and diagnostic areas
- *Backup mechanisms*: Easy data export/import via GUI

## ğŸ“ˆ Performance Characteristics

| Operation | UART Speed | SPI Speed | Notes |
|-----------|------------|-----------|-------|
| Single Read | ~10ms | ~1ms | Including protocol overhead |
| Single Write | ~15ms | ~5ms | Including EEPROM write time |
| Bulk Read (1KB) | ~2s | ~500ms | Large transfers |
| Bulk Write (1KB) | ~15s | ~5s | EEPROM write limitations |

## ğŸ¤ Contributing

### Adding New Commands
1. *Arduino Side*: Add command ID to constants and implement in processFrame()
2. *Java Side*: Add GUI button and frame builder method
3. *Documentation*: Update command table and protocol specs

### Extending Memory Services
java
// Example: Add new memory region
public static final int CONFIG_START = 0x0800;
public static final int CONFIG_END   = 0x0BFF;

public String readConfig() {
    return "[NVM] READ_CONFIG | Addr=0x0800â€“0x0BFF";
}


## ğŸ“„ License

This project is provided as an educational and development tool. Feel free to modify and extend for your specific applications.

## ğŸ“ Support

For technical questions:
- Check the trace logs for communication details
- Verify hardware connections
- Review Arduino serial monitor output
- Test with simple read/write operations first

---

This EEPROM management system demonstrates professional embedded development practices with robust communication protocols and comprehensive debugging tools.
