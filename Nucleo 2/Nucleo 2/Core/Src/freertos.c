/**
 * Fixed STM32 Seat Controller Code
 * Issues Fixed: I2C communication, SPI EEPROM, Profile Management, Auto mode ADC reading
 */

#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"
#include "main.h"
#include "gpio.h"
#include "usart.h"
#include "adc.h"
#include "spi.h"
#include "i2c.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

// ========== FIXED DEFINITIONS ==========
// Use pin definitions from Core/Inc/main.h (generated by CubeMX)
#define I2C_SLAVE_ADD 0x50  // Arduino Nano address

// CRITICAL: You must define your SPI CS pin here
// Replace with your actual GPIO port and pin
#define SPI_CS_GPIO_Port    GPIOB
#define SPI_CS_Pin          GPIO_PIN_12

// SPI EEPROM Commands (must match Arduino Uno)
#define SPI_CMD_READ_BYTE     0x03  // Standard EEPROM read command
#define SPI_CMD_WRITE_BYTE    0x02  // Standard EEPROM write command
#define SPI_CMD_READ_STATUS   0x05  // Read status register
#define SPI_CMD_WRITE_ENABLE  0x06  // Write enable

#define SPI_TIMEOUT           1000
#define EEPROM_SIZE           256   // Reduced size for testing
#define PROFILE_ADDR          0x111  // Store profile at address 0

typedef enum {
    MANUAL_MODE = 0,
    AUTOMATIC_MODE,
} Mode_Selection_t;
volatile Mode_Selection_t DefaultMode = MANUAL_MODE;

typedef enum {
    STATE_OFF = 0,
    STATE_IDLE,
    STATE_LOCKED,
    STATE_MOVING,
    STATE_ERROR
} SeatState_t;
volatile SeatState_t CurrentState = STATE_OFF;

typedef enum {
    SPI_IDLE = 0,
    SPI_READING,
    SPI_WRITING,
    SPI_ERROR
} SPI_State_t;
volatile SPI_State_t SPI_CurrentState = SPI_IDLE;

// Enhanced seat status for I2C communication
#pragma pack(push,1)
typedef struct {
    uint16_t height;
    uint16_t slide;
    uint16_t incline;
    uint8_t mode;        // 'M' or 'A'
    uint8_t state;       // FSM state
    uint16_t checksum;   // Data integrity
} SeatStatus_t;
#pragma pack(pop)

// Profile data structure
#pragma pack(push,1)
typedef struct {
    uint16_t height;
    uint16_t slide;
    uint16_t incline;
    uint8_t valid;       // 0xAA if valid profile
    uint16_t checksum;
} Profile_Data_t;
#pragma pack(pop)

// Calibration data
#pragma pack(push,1)
typedef struct {
    uint16_t height_offset;
    uint16_t height_coeff;
    uint16_t slide_offset;
    uint16_t slide_coeff;
    uint16_t incline_offset;
    uint16_t incline_coeff;
    uint16_t checksum;
} Calibration_Data_t;
#pragma pack(pop)

// Global variables
SeatStatus_t SeatST;
Profile_Data_t ProfileData;
Calibration_Data_t CalibData;

// Current seat position values
volatile uint32_t Height_Variable  = 25;  // 2.5 cm default
volatile uint32_t Slide_Variable   = 50;  // 5.0 cm default
volatile uint32_t Incline_Variable = 850; // 85.0 degrees default

// Measured and physical values
volatile uint32_t Height_Measured  = 0;
volatile uint32_t Slide_Measured   = 0;
volatile uint32_t Incline_Measured = 0;
volatile uint32_t Height_Physical  = 25;
volatile uint32_t Slide_Physical   = 50;
volatile uint32_t Incline_Physical = 8500;

// Profile management
volatile uint8_t profile_save_request = 0;
volatile uint8_t profile_load_request = 0;

// FreeRTOS handles
osThreadId_t SwitchModeHandle;
osThreadId_t AdcHeightHandle;
osThreadId_t AdcSlideHandle;
osThreadId_t AdcInclineHandle;
osThreadId_t Buttons_Read_Manual_mode_high;
osThreadId_t Buttons_Read_Manual_mode_Low;
osThreadId_t UART_TaskHandle;
osThreadId_t i2c_taskHandle;
osThreadId_t i2c_seatStatus_handle;
osThreadId_t fsmTaskHandle;
osThreadId_t spiEepromTaskHandle;
osThreadId_t calibrationTaskHandle;
osThreadId_t profileManagerTaskHandle;

osMessageQueueId_t UartQueueHandle;
osMutexId_t i2cMutexHandle;
osMutexId_t spiMutexHandle;

// Task attributes (same as your original)
const osThreadAttr_t switchmode_attributes = {
    .name = "SwitchModeTask",
    .stack_size = 128 * 4,
    .priority = (osPriority_t) osPriorityHigh,
};

const osThreadAttr_t adcHeight_attributes = {
    .name = "AdcHeightTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t adcSlide_attributes = {
    .name = "AdcSlideTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t adcIncline_attributes = {
    .name = "AdcInclineTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t Buttons_Attributes = {
    .name = "ButtonsHighAttrib", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t Button_attrib_low = {
    .name = "ButtonsLowAttrib", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t uartTask_attributes = {
    .name = "UARTTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t i2c_attributes = {
    .name = "i2cdef", .priority = (osPriority_t) osPriorityNormal, .stack_size = 128 * 4
};

const osThreadAttr_t i2c_statehandle = {
    .name = "i2cState", .priority = (osPriority_t) osPriorityBelowNormal, .stack_size = 128 * 4
};

const osThreadAttr_t fsmTask_attributes = {
    .name = "FSM_Task", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityAboveNormal,
};

const osThreadAttr_t spiEeprom_attributes = {
    .name = "SPI_EEPROM_Task", .stack_size = 128 * 8, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t calibration_attributes = {
    .name = "Calibration_Task", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityLow,
};

const osThreadAttr_t profileManager_attributes = {
    .name = "ProfileManager_Task", .stack_size = 128 * 6, .priority = (osPriority_t) osPriorityNormal,
};

// Function prototypes
void SwitchModeTask(void *argument);
void AdcHeightTask(void *argument);
void AdcSlideTask(void *argument);
void AdcInclineTask(void *argument);
void Buttons_ReadTask_highmode(void *argument);
void Buttons_ReadTask_Lowmode(void *argument);
void UART_Task(void *argument);
void i2cTask(void *argument);
void i2_handle_seatstatus(void * argument);
void FSM_Task(void * argument);
void SPI_EEPROM_Task(void *argument);
void Calibration_Task(void *argument);
void ProfileManager_Task(void *argument);

uint32_t Read_ADC_Channel(uint32_t channel);
HAL_StatusTypeDef SPI_EEPROM_ReadByte(uint16_t address, uint8_t *data);
HAL_StatusTypeDef SPI_EEPROM_WriteByte(uint16_t address, uint8_t data);
void Calculate_Physical_Values(void);
uint16_t Calculate_Checksum(Calibration_Data_t *data);
uint16_t Calculate_ProfileChecksum(Profile_Data_t *p);
uint16_t Calculate_SeatChecksum(SeatStatus_t *s);

void MX_FREERTOS_Init(void)
{
    UartQueueHandle = osMessageQueueNew(10, 50, NULL);

    const osMutexAttr_t i2cMutexAttr = { .name = "i2cMutex" };
    i2cMutexHandle = osMutexNew(&i2cMutexAttr);

    const osMutexAttr_t spiMutexAttr = { .name = "spiMutex" };
    spiMutexHandle = osMutexNew(&spiMutexAttr);

    // Create all tasks
    SwitchModeHandle               = osThreadNew(SwitchModeTask, NULL, &switchmode_attributes);
    AdcHeightHandle                = osThreadNew(AdcHeightTask, NULL, &adcHeight_attributes);
    AdcSlideHandle                 = osThreadNew(AdcSlideTask,  NULL, &adcSlide_attributes);
    AdcInclineHandle               = osThreadNew(AdcInclineTask, NULL, &adcIncline_attributes);
    Buttons_Read_Manual_mode_high  = osThreadNew(Buttons_ReadTask_highmode, NULL, &Buttons_Attributes);
    Buttons_Read_Manual_mode_Low   = osThreadNew(Buttons_ReadTask_Lowmode, NULL, &Button_attrib_low);
    UART_TaskHandle                = osThreadNew(UART_Task, NULL, &uartTask_attributes);
    i2c_taskHandle                 = osThreadNew(i2cTask, NULL, &i2c_attributes);
    i2c_seatStatus_handle          = osThreadNew(i2_handle_seatstatus, NULL, &i2c_statehandle);
    fsmTaskHandle                  = osThreadNew(FSM_Task, NULL, &fsmTask_attributes);
    spiEepromTaskHandle            = osThreadNew(SPI_EEPROM_Task, NULL, &spiEeprom_attributes);
    calibrationTaskHandle          = osThreadNew(Calibration_Task, NULL, &calibration_attributes);
    profileManagerTaskHandle       = osThreadNew(ProfileManager_Task, NULL, &profileManager_attributes);
}

void UART_Task(void *argument)
{
    char msg[50];
    for(;;)
    {
        if (osMessageQueueGet(UartQueueHandle, msg, NULL, osWaitForever) == osOK)
        {
            msg[49] = '\0';
            HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        }
    }
}

// ========== FIXED SPI FUNCTIONS ==========
HAL_StatusTypeDef SPI_EEPROM_ReadByte(uint16_t address, uint8_t *data)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT) == osOK)
    {
        uint8_t tx_buf[4] = {SPI_CMD_READ_BYTE, (address >> 8) & 0xFF, address & 0xFF, 0x00};
        uint8_t rx_buf[4];

        // Select device
        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
        osDelay(1);

        // Send command and receive data
        if(HAL_SPI_TransmitReceive(&hspi2, tx_buf, rx_buf, 4, SPI_TIMEOUT) == HAL_OK)
        {
            *data = rx_buf[3]; // Data comes back in 4th byte
            result = HAL_OK;
        }

        // Deselect device
        osDelay(1);
        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

HAL_StatusTypeDef SPI_EEPROM_WriteByte(uint16_t address, uint8_t data)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT) == osOK)
    {
        // Write enable first
        uint8_t write_enable = SPI_CMD_WRITE_ENABLE;

        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
        HAL_SPI_Transmit(&hspi2, &write_enable, 1, SPI_TIMEOUT);
        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

        osDelay(1);

        // Write data
        uint8_t tx_buf[4] = {SPI_CMD_WRITE_BYTE, (address >> 8) & 0xFF, address & 0xFF, data};

        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);

        if(HAL_SPI_Transmit(&hspi2, tx_buf, 4, SPI_TIMEOUT) == HAL_OK)
        {
            result = HAL_OK;
        }

        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

        osDelay(5); // Write cycle time

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

// ========== FIXED I2C FUNCTIONS ==========
void i2_handle_seatstatus(void * argument)
{
    char uart_msg_ok[]  = "I2C seat status sent\r\n";
    char errbuf[64];

    uint8_t txBuffer[sizeof(SeatStatus_t)];

    for(;;)
    {
        // Update seat status with current values
        SeatST.height   = (uint16_t)Height_Physical;
        SeatST.slide    = (uint16_t)Slide_Physical;
        SeatST.incline  = (uint16_t)Incline_Physical;
        SeatST.mode     = (DefaultMode == MANUAL_MODE) ? 'M' : 'A';
        SeatST.state    = (uint8_t)CurrentState;
        SeatST.checksum = Calculate_SeatChecksum(&SeatST);

        memcpy(txBuffer, &SeatST, sizeof(SeatST));

        if (osMutexAcquire(i2cMutexHandle, 500) == osOK)
        {
            // Try to transmit to Arduino Nano bridge
            HAL_StatusTypeDef res = HAL_I2C_Master_Transmit(&hi2c1,
                                                            (I2C_SLAVE_ADD << 1),
                                                            txBuffer,
                                                            sizeof(txBuffer),
                                                            500);

            osMutexRelease(i2cMutexHandle);

            if (res == HAL_OK)
            {
                osMessageQueuePut(UartQueueHandle, uart_msg_ok, 0, 10);
            }
            else
            {
                int len = snprintf(errbuf, sizeof(errbuf), "I2C seat error=%d\r\n", (int)res);
                if(len > 0) osMessageQueuePut(UartQueueHandle, errbuf, 0, 10);
            }
        }

        osDelay(100); // Send every 100ms
    }
}

void i2cTask(void *argument)
{
    uint8_t mode_data[2];
    char uart_msg_ok[]  = "I2C mode sent\r\n";
    char errbuf[64];

    for(;;)
    {
        mode_data[0] = 0x01; // Mode message ID
        mode_data[1] = (DefaultMode == AUTOMATIC_MODE) ? 'A' : 'M';

        if (osMutexAcquire(i2cMutexHandle, 500) == osOK)
        {
            HAL_StatusTypeDef res = HAL_I2C_Master_Transmit(&hi2c1,
                                                            (I2C_SLAVE_ADD << 1),
                                                            mode_data,
                                                            2,
                                                            500);
            osMutexRelease(i2cMutexHandle);

            if (res == HAL_OK)
            {
                osMessageQueuePut(UartQueueHandle, uart_msg_ok, 0, 10);
            }
            else
            {
                int len = snprintf(errbuf, sizeof(errbuf), "I2C mode error=%d\r\n", (int)res);
                if(len > 0) osMessageQueuePut(UartQueueHandle, errbuf, 0, 10);
            }
        }

        osDelay(2000); // Send every 2 seconds
    }
}

// ========== FIXED ADC TASKS - READ IN BOTH MODES ==========
void AdcHeightTask(void *argument)
{
    char msg[60];

    for(;;)
    {
        uint32_t value = Read_ADC_Channel(ADC_CHANNEL_11);

        taskENTER_CRITICAL();
        Height_Variable = value;
        taskEXIT_CRITICAL();

        if(DefaultMode == MANUAL_MODE)
        {
            int len = snprintf(msg, sizeof(msg), "Height: raw=%lu, phys=%lu\r\n", value, Height_Physical);
            if (len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
        }

        osDelay(200);
    }
}

void AdcSlideTask(void *argument)
{
    char msg[60];

    for(;;)
    {
        uint32_t value = Read_ADC_Channel(ADC_CHANNEL_12);

        taskENTER_CRITICAL();
        Slide_Variable = value;
        taskEXIT_CRITICAL();

        if(DefaultMode == MANUAL_MODE)
        {
            int len = snprintf(msg, sizeof(msg), "Slide: raw=%lu, phys=%lu\r\n", value, Slide_Physical);
            if (len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
        }

        osDelay(250);
    }
}

void AdcInclineTask(void *argument)
{
    char msg[60];

    for(;;)
    {
        uint32_t value = Read_ADC_Channel(ADC_CHANNEL_13);

        taskENTER_CRITICAL();
        Incline_Variable = value;
        taskEXIT_CRITICAL();

        if(DefaultMode == MANUAL_MODE)
        {
            int len = snprintf(msg, sizeof(msg), "Incline: raw=%lu, phys=%lu\r\n", value, Incline_Physical);
            if (len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
        }

        osDelay(300);
    }
}

// ========== FIXED PROFILE MANAGER ==========
void ProfileManager_Task(void *argument)
{
    char msg[100];
    static uint8_t save_btn_prev = 0, load_btn_prev = 0;
    uint8_t save_btn_current, load_btn_current;

    osMessageQueuePut(UartQueueHandle, "ProfileManager Started\r\n", 0, 10);

    for(;;)
    {
        if(DefaultMode == AUTOMATIC_MODE)
        {
            // Save Profile - Blue button PC13
            save_btn_current = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_11);
            if(save_btn_current == GPIO_PIN_SET && save_btn_prev == GPIO_PIN_RESET)
            {
                // Read current ADC values
                ProfileData.height  = (uint16_t)Height_Variable;
                ProfileData.slide   = (uint16_t)Slide_Variable;
                ProfileData.incline = (uint16_t)Incline_Variable;
                ProfileData.valid   = 0xAA; // Valid marker
                ProfileData.checksum = Calculate_ProfileChecksum(&ProfileData);

                // Save to EEPROM byte by byte
                uint8_t *data_ptr = (uint8_t*)&ProfileData;
                HAL_StatusTypeDef result = HAL_OK;

                for(int i = 0; i < sizeof(Profile_Data_t); i++)
                {
                    if(SPI_EEPROM_WriteByte(PROFILE_ADDR + i, data_ptr[i]) != HAL_OK)
                    {
                        result = HAL_ERROR;
                        break;
                    }
                    osDelay(10); // Write delay
                }

                if(result == HAL_OK)
                {
                    int len = snprintf(msg, sizeof(msg), "Profile Saved: H=%u S=%u I=%u\r\n",
                                      ProfileData.height, ProfileData.slide, ProfileData.incline);
                    if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
                }
                else
                {
                    osMessageQueuePut(UartQueueHandle, "Profile Save Failed\r\n", 0, 10);
                }
            }
            save_btn_prev = save_btn_current;

            // Load Profile - User button PA0
            load_btn_current = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_10);
            if(load_btn_current == GPIO_PIN_SET && load_btn_prev == GPIO_PIN_RESET)
            {
                // Read from EEPROM byte by byte
                uint8_t *data_ptr = (uint8_t*)&ProfileData;
                HAL_StatusTypeDef result = HAL_OK;

                for(int i = 0; i < sizeof(Profile_Data_t); i++)
                {
                    if(SPI_EEPROM_ReadByte(PROFILE_ADDR + i, &data_ptr[i]) != HAL_OK)
                    {
                        result = HAL_ERROR;
                        break;
                    }
                    osDelay(1);
                }

                if(result == HAL_OK && ProfileData.valid == 0xAA &&
                   ProfileData.checksum == Calculate_ProfileChecksum(&ProfileData))
                {
                    // Apply loaded profile - set target values
                    taskENTER_CRITICAL();
                    Height_Variable = ProfileData.height;
                    Slide_Variable = ProfileData.slide;
                    Incline_Variable = ProfileData.incline;
                    taskEXIT_CRITICAL();

                    int len = snprintf(msg, sizeof(msg), "Profile Loaded: H=%u S=%u I=%u\r\n",
                                      ProfileData.height, ProfileData.slide, ProfileData.incline);
                    if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
                }
                else
                {
                    osMessageQueuePut(UartQueueHandle, "Profile Load Failed/Invalid\r\n", 0, 10);
                }
            }
            load_btn_prev = load_btn_current;
        }
        else
        {
            // Reset button states in manual mode
            save_btn_prev = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_11);
            load_btn_prev = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_10);
        }

        osDelay(50);
    }
}

// ========== SPI EEPROM TASK ==========
void SPI_EEPROM_Task(void *argument)
{
    char msg[80];
    uint8_t test_data = 0;

    osMessageQueuePut(UartQueueHandle, "SPI EEPROM Task Started\r\n", 0, 10);

    // Initialize CS pin
    HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

    for(;;)
    {
        // Test SPI communication
        if(SPI_EEPROM_ReadByte(0x00, &test_data) == HAL_OK)
        {
            int len = snprintf(msg, sizeof(msg), "SPI OK: addr=0x00, data=0x%02X\r\n", test_data);
            if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
        }
        else
        {
            osMessageQueuePut(UartQueueHandle, "SPI Test Failed\r\n", 0, 10);
        }

        osDelay(5000);
    }
}

// ========== OTHER TASKS (SAME AS ORIGINAL) ==========
void SwitchModeTask(void *argument)
{
    char msg_auto[]   = "AUTO mode - Profile Save/Load active\r\n";
    char msg_manual[] = "MANUAL mode - Button control active\r\n";

    for(;;)
    {
        if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET)
        {
            // Wait for button release to avoid multiple toggles
            osDelay(200);

            taskENTER_CRITICAL();
            DefaultMode = (DefaultMode == MANUAL_MODE) ? AUTOMATIC_MODE : MANUAL_MODE;
            taskEXIT_CRITICAL();

            if(DefaultMode == AUTOMATIC_MODE)
                osMessageQueuePut(UartQueueHandle, msg_auto, 0, 10);
            else
                osMessageQueuePut(UartQueueHandle, msg_manual, 0, 10);

            while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) {
                osDelay(10);
            }
        }
        osDelay(50);
    }
}

void Buttons_ReadTask_highmode(void * argument)
{
    char msg1[] = "Height Increase\r\n";
    char msg2[] = "Slide Increase\r\n";
    char msg3[] = "Incline Increase\r\n";

    for(;;)
    {
        if(DefaultMode == MANUAL_MODE)
        {
            if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Height_Variable < 53) Height_Variable++;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg1, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Slide_Variable < 75) Slide_Variable++;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg2, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Incline_Variable < 1053) Incline_Variable++;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg3, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7) == GPIO_PIN_SET) osDelay(10);
            }
        }
        osDelay(500);
    }
}

void Buttons_ReadTask_Lowmode(void * argument)
{
    char msg1[] = "Height Decrease\r\n";
    char msg2[] = "Slide Decrease\r\n";
    char msg3[] = "Incline Decrease\r\n";

    for(;;)
    {
        if (DefaultMode == MANUAL_MODE)
        {
            if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_4) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Height_Variable > 20) Height_Variable--;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg1, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_4) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_5) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Slide_Variable > 30) Slide_Variable--;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg2, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_5) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Incline_Variable > 675) Incline_Variable--;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg3, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET) osDelay(10);
            }
        }
        osDelay(500);
    }
}

void Calibration_Task(void *argument)
{
    char msg[100];

    osMessageQueuePut(UartQueueHandle, "Calibration Task Started\r\n", 0, 10);

    // Initialize default calibration
    CalibData.height_offset = 0;
    CalibData.height_coeff = 1000;
    CalibData.slide_offset = 0;
    CalibData.slide_coeff = 1000;
    CalibData.incline_offset = 0;
    CalibData.incline_coeff = 1000;
    CalibData.checksum = Calculate_Checksum(&CalibData);

    for(;;)
    {
        // Calculate physical values using calibration
        Calculate_Physical_Values();

        int len = snprintf(msg, sizeof(msg), "Calib: H_coeff=%u S_coeff=%u I_coeff=%u\r\n",
                          CalibData.height_coeff, CalibData.slide_coeff, CalibData.incline_coeff);
        if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);

        osDelay(10000); // Every 10 seconds
    }
}

void FSM_Task(void *argument)
{
    static uint32_t last_state_change = 0;

    for(;;)
    {
        SeatState_t previous_state = CurrentState;

        switch(CurrentState)
        {
            case STATE_OFF:
                if(DefaultMode == AUTOMATIC_MODE || DefaultMode == MANUAL_MODE)
                {
                    CurrentState = STATE_IDLE;
                    osMessageQueuePut(UartQueueHandle, "FSM: OFF -> IDLE\r\n", 0, 10);
                }
                break;

            case STATE_IDLE:
                // Normal idle state
                if(Height_Physical != Height_Variable ||
                   Slide_Physical != Slide_Variable ||
                   Incline_Physical != Incline_Variable)
                {
                    CurrentState = STATE_MOVING;
                    osMessageQueuePut(UartQueueHandle, "FSM: IDLE -> MOVING\r\n", 0, 10);
                }
                break;

            case STATE_MOVING:
                // Check if reached target position
                if(abs(Height_Physical - Height_Variable) < 2 &&
                   abs(Slide_Physical - Slide_Variable) < 2 &&
                   abs(Incline_Physical - Incline_Variable) < 20)
                {
                    CurrentState = STATE_IDLE;
                    osMessageQueuePut(UartQueueHandle, "FSM: MOVING -> IDLE\r\n", 0, 10);
                }

                // Check for error conditions
                if(Height_Physical > 60 || Slide_Physical > 80 || Incline_Physical > 11000)
                {
                    CurrentState = STATE_ERROR;
                    osMessageQueuePut(UartQueueHandle, "FSM: MOVING -> ERROR\r\n", 0, 10);
                }
                break;

            case STATE_ERROR:
                // Stay in error until manual reset
                osMessageQueuePut(UartQueueHandle, "FSM: ERROR STATE\r\n", 0, 10);
                osDelay(1000);
                CurrentState = STATE_IDLE; // Auto recovery for demo
                break;

            default:
                CurrentState = STATE_OFF;
                break;
        }

        if(CurrentState != previous_state)
        {
            last_state_change = HAL_GetTick();
        }

        osDelay(100);
    }
}

uint32_t Read_ADC_Channel(uint32_t channel)
{
    ADC_ChannelConfTypeDef sConfig = {0};

    sConfig.Channel = channel;
    sConfig.Rank = 1;
    sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;

    HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    uint32_t value = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);

    return value;
}

void Calculate_Physical_Values(void)
{
    // Apply calibration to convert raw values to physical values
    Height_Measured = (Height_Variable * CalibData.height_coeff) / 1000 + CalibData.height_offset;
    Slide_Measured = (Slide_Variable * CalibData.slide_coeff) / 1000 + CalibData.slide_offset;
    Incline_Measured = (Incline_Variable * CalibData.incline_coeff) / 1000 + CalibData.incline_offset;

    // Keep values within valid ranges (as per PDF spec)
    if(Height_Measured < 20) Height_Physical = 20;        // 2.0 cm minimum
    else if(Height_Measured > 53) Height_Physical = 53;   // 5.3 cm maximum
    else Height_Physical = Height_Measured;

    if(Slide_Measured < 30) Slide_Physical = 30;          // 3.0 cm minimum
    else if(Slide_Measured > 75) Slide_Physical = 75;     // 7.5 cm maximum
    else Slide_Physical = Slide_Measured;

    if(Incline_Measured < 6753) Incline_Physical = 6753;  // 67°5'30" minimum
    else if(Incline_Measured > 10553) Incline_Physical = 10553; // 105°5'30" maximum
    else Incline_Physical = Incline_Measured;
}

uint16_t Calculate_Checksum(Calibration_Data_t *data)
{
    uint16_t checksum = 0;
    uint8_t *ptr = (uint8_t*)data;

    // Calculate checksum excluding the checksum field itself
    for(int i = 0; i < (sizeof(Calibration_Data_t) - sizeof(uint16_t)); i++)
    {
        checksum += ptr[i];
    }

    return checksum;
}

uint16_t Calculate_ProfileChecksum(Profile_Data_t *p)
{
    return (p->height + p->slide + p->incline + p->valid) & 0xFFFF;
}

uint16_t Calculate_SeatChecksum(SeatStatus_t *s)
{
    return (s->height + s->slide + s->incline + s->mode + s->state) & 0xFFFF;
}
