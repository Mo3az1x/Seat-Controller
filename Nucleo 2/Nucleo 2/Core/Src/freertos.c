/**
  * Fixed STM32 Seat Controller Code
  * Issues Fixed: I2C communication, SPI EEPROM, Profile Management, Auto mode ADC reading
  */

#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"
#include "main.h"
#include "gpio.h"
#include "usart.h"
#include "adc.h"
#include "spi.h"
#include "i2c.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "rte.h"

// ========== FIXED DEFINITIONS ==========
// Use pin definitions from Core/Inc/main.h (generated by CubeMX)

// CRITICAL: You must define your SPI CS pin here
// Replace with your actual GPIO port and pin

// SPI EEPROM Command Constants
#define SPI_CMD_READ_BYTE      0x03
#define SPI_CMD_WRITE_BYTE     0x02
#define SPI_CMD_WRITE_ENABLE   0x06
#define SPI_TIMEOUT            1000
#define PROFILE_BASE_ADDR      0x100  // Base address for profiles in EEPROM


typedef enum {
    MANUAL_MODE = 0,
    AUTOMATIC_MODE,
} Mode_Selection_t;
volatile Mode_Selection_t DefaultMode = MANUAL_MODE;

typedef enum {
    STATE_OFF = 0,
    STATE_IDLE,
    STATE_LOCKED,
    STATE_MOVING,
    STATE_ERROR,
    STATE_DRIVING  // New state for driving mode
} SeatState_t;
volatile SeatState_t CurrentState = STATE_OFF;

typedef enum {
    GEAR_PARK = 0,
    GEAR_DRIVE
} GearState_t;
volatile GearState_t CurrentGear = GEAR_PARK;

typedef enum {
    SPI_IDLE = 0,
    SPI_READING,
    SPI_WRITING,
    SPI_ERROR
} SPI_State_t;
volatile SPI_State_t SPI_CurrentState = SPI_IDLE;

// Profile data structure (updated to match requirements)
#pragma pack(push,1)
typedef struct {
    uint16_t height;
    uint16_t slide;
    uint16_t incline;
    uint16_t checksum; // sum of values for validation
} SeatProfile;
#pragma pack(pop)

// Legacy typedef for compatibility
typedef SeatProfile Profile_Data_t;

// Enhanced seat status for I2C communication
#pragma pack(push,1)
typedef struct {
    uint16_t height;
    uint16_t slide;
    uint16_t incline;
    uint8_t mode;        // 'M' or 'A'
    uint8_t state;       // FSM state
    uint16_t checksum;   // Data integrity
} SeatStatus_t;
#pragma pack(pop)

// EEPROM Command Types for inter-task communication
typedef enum {
    EEPROM_SAVE = 0,
    EEPROM_LOAD
} EEPROM_Command_t;

// Message structure for ProfileManager-SPI_EEPROM communication
typedef struct {
    EEPROM_Command_t command;
    uint8_t profile_id;
    SeatProfile profile_data;
    uint32_t result; // HAL_OK or HAL_ERROR
} EEPROM_Message_t;

// Calibration data
#pragma pack(push,1)
typedef struct {
    uint16_t height_offset;
    uint16_t height_coeff;
    uint16_t slide_offset;
    uint16_t slide_coeff;
    uint16_t incline_offset;
    uint16_t incline_coeff;
    uint16_t checksum;
} Calibration_Data_t;
#pragma pack(pop)

// Global variables
SeatStatus_t SeatST;
Profile_Data_t ProfileData;
Calibration_Data_t CalibData;
volatile uint8_t GearButtonPressed = 0; // Flag for gear button press detection

// Inter-task communication
osMessageQueueId_t EEPROMQueueHandle;
osMessageQueueId_t UartQueueHandle;
osMutexId_t i2cMutexHandle;
osMutexId_t spiMutexHandle;

// Current seat position values
volatile uint32_t Height_Variable  = 25;  // 2.5 cm default
volatile uint32_t Slide_Variable   = 50;  // 5.0 cm default
volatile uint32_t Incline_Variable = 850; // 85.0 degrees default

// Measured and physical values
volatile uint32_t Height_Measured  = 0;
volatile uint32_t Slide_Measured   = 0;
volatile uint32_t Incline_Measured = 0;
volatile uint32_t Height_Physical  = 25;
volatile uint32_t Slide_Physical   = 50;
volatile uint32_t Incline_Physical = 8500;

// Track last state change timestamp (used by FSM_Task)
volatile uint32_t last_state_change = 0;

// Profile management
volatile uint8_t profile_save_request = 0;
volatile uint8_t profile_load_request = 0;

// FreeRTOS handles
osThreadId_t SwitchModeHandle;
osThreadId_t AdcHeightHandle;
osThreadId_t AdcSlideHandle;
osThreadId_t AdcInclineHandle;
osThreadId_t Buttons_Read_Manual_mode_high;
osThreadId_t Buttons_Read_Manual_mode_Low;
osThreadId_t UART_TaskHandle;
osThreadId_t i2c_taskHandle;
osThreadId_t fsmTaskHandle;
osThreadId_t spiEepromTaskHandle;
osThreadId_t calibrationTaskHandle;
osThreadId_t profileManagerTaskHandle;
osThreadId_t gearButtonTaskHandle; // Handle for gear button task

// Task attributes
const osThreadAttr_t switchmode_attributes = {
    .name = "SwitchModeTask",
    .stack_size = 128 * 4,
    .priority = (osPriority_t) osPriorityHigh,
};

const osThreadAttr_t adcHeight_attributes = {
    .name = "AdcHeightTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t adcSlide_attributes = {
    .name = "AdcSlideTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t adcIncline_attributes = {
    .name = "AdcInclineTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t Buttons_Attributes = {
    .name = "ButtonsHighAttrib", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t Button_attrib_low = {
    .name = "ButtonsLowAttrib", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t uartTask_attributes = {
    .name = "UARTTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t i2c_attributes = {
    .name = "i2cdef", .priority = (osPriority_t) osPriorityNormal, .stack_size = 128 * 4
};

const osThreadAttr_t fsmTask_attributes = {
    .name = "FSM_Task", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityAboveNormal,
};

const osThreadAttr_t gearButton_attributes = {
    .name = "GearButtonTask", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t spiEeprom_attributes = {
    .name = "SPI_EEPROM_Task", .stack_size = 128 * 8, .priority = (osPriority_t) osPriorityNormal,
};

const osThreadAttr_t calibration_attributes = {
    .name = "Calibration_Task", .stack_size = 128 * 4, .priority = (osPriority_t) osPriorityLow,
};

const osThreadAttr_t profileManager_attributes = {
    .name = "ProfileManager_Task", .stack_size = 128 * 6, .priority = (osPriority_t) osPriorityNormal,
};

// Function prototypes
void SwitchModeTask(void *argument);
void AdcHeightTask(void *argument);
void AdcSlideTask(void *argument);
void AdcInclineTask(void *argument);
void Buttons_ReadTask_highmode(void *argument);
void Buttons_ReadTask_Lowmode(void *argument);
void UART_Task(void *argument);
void i2cTask(void *argument);
void FSM_Task(void * argument);
void SPI_EEPROM_Task(void *argument);
void Calibration_Task(void *argument);
void ProfileManager_Task(void *argument);
void GearButton_Task(void *argument); // New gear button task prototype

uint32_t Read_ADC_Channel(uint32_t channel);
HAL_StatusTypeDef SPI_EEPROM_ReadByte(uint16_t address, uint8_t *data);
HAL_StatusTypeDef SPI_EEPROM_WriteByte(uint16_t address, uint8_t data);
void Calculate_Physical_Values(void);
uint16_t Calculate_Checksum(Calibration_Data_t *data);
uint16_t Calculate_ProfileChecksum(Profile_Data_t *p);
uint16_t Calculate_SeatChecksum(SeatStatus_t *s);
uint16_t Calculate_SeatProfileChecksum(SeatProfile *p);
HAL_StatusTypeDef SaveProfile(uint8_t profile_id, SeatProfile *p);
HAL_StatusTypeDef LoadProfile(uint8_t profile_id, SeatProfile *p);

void MX_FREERTOS_Init(void)
{
    UartQueueHandle = osMessageQueueNew(10, 50, NULL);
    EEPROMQueueHandle = osMessageQueueNew(5, sizeof(EEPROM_Message_t), NULL);

    const osMutexAttr_t i2cMutexAttr = { .name = "i2cMutex" };
    i2cMutexHandle = osMutexNew(&i2cMutexAttr);

    const osMutexAttr_t spiMutexAttr = { .name = "spiMutex" };
    spiMutexHandle = osMutexNew(&spiMutexAttr);

    // Create all tasks
    SwitchModeHandle               = osThreadNew(SwitchModeTask, NULL, &switchmode_attributes);
    AdcHeightHandle                = osThreadNew(AdcHeightTask, NULL, &adcHeight_attributes);
    AdcSlideHandle                 = osThreadNew(AdcSlideTask,  NULL, &adcSlide_attributes);
    AdcInclineHandle               = osThreadNew(AdcInclineTask, NULL, &adcIncline_attributes);
    Buttons_Read_Manual_mode_high  = osThreadNew(Buttons_ReadTask_highmode, NULL, &Buttons_Attributes);
    Buttons_Read_Manual_mode_Low   = osThreadNew(Buttons_ReadTask_Lowmode, NULL, &Button_attrib_low);
    UART_TaskHandle                = osThreadNew(UART_Task, NULL, &uartTask_attributes);
    i2c_taskHandle                 = osThreadNew(i2cTask, NULL, &i2c_attributes);
    fsmTaskHandle                  = osThreadNew(FSM_Task, NULL, &fsmTask_attributes);
    spiEepromTaskHandle            = osThreadNew(SPI_EEPROM_Task, NULL, &spiEeprom_attributes);
    calibrationTaskHandle          = osThreadNew(Calibration_Task, NULL, &calibration_attributes);
    profileManagerTaskHandle       = osThreadNew(ProfileManager_Task, NULL, &profileManager_attributes);
    gearButtonTaskHandle           = osThreadNew(GearButton_Task, NULL, &gearButton_attributes); // Create gear button task
}

void UART_Task(void *argument)
{
    char msg[50];
    Rte_Trace("UART task started");
    for(;;)
    {
        if (osMessageQueueGet(UartQueueHandle, msg, NULL, osWaitForever) == osOK)
        {
            msg[49] = '\0';
            HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        }
    }
}

// ========== FIXED SPI FUNCTIONS ==========
HAL_StatusTypeDef SPI_EEPROM_ReadByte(uint16_t address, uint8_t *data)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT) == osOK)
    {
        uint8_t tx_buf[4] = {SPI_CMD_READ_BYTE, (address >> 8) & 0xFF, address & 0xFF, 0x00};
        uint8_t rx_buf[4];

        // Select device
        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
        osDelay(1);

        // Send command and receive data
        if(HAL_SPI_TransmitReceive(&hspi2, tx_buf, rx_buf, 4, SPI_TIMEOUT) == HAL_OK)
        {
            *data = rx_buf[3]; // Data comes back in 4th byte
            result = HAL_OK;
        }

        // Deselect device
        osDelay(1);
        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

HAL_StatusTypeDef SPI_EEPROM_WriteByte(uint16_t address, uint8_t data)
{
    HAL_StatusTypeDef result = HAL_ERROR;

    if (osMutexAcquire(spiMutexHandle, SPI_TIMEOUT) == osOK)
    {
        // Write enable first
        uint8_t write_enable = SPI_CMD_WRITE_ENABLE;

        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);
        HAL_SPI_Transmit(&hspi2, &write_enable, 1, SPI_TIMEOUT);
        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

        osDelay(1);

        // Write data
        uint8_t tx_buf[4] = {SPI_CMD_WRITE_BYTE, (address >> 8) & 0xFF, address & 0xFF, data};

        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);

        if(HAL_SPI_Transmit(&hspi2, tx_buf, 4, SPI_TIMEOUT) == HAL_OK)
        {
            result = HAL_OK;
        }

        HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

        osDelay(5); // Write cycle time

        osMutexRelease(spiMutexHandle);
    }

    return result;
}

// ========== FIXED I2C FUNCTIONS ==========
void i2cTask(void *argument)
{
    uint8_t mode_data[2];
    uint8_t txBuffer[sizeof(SeatStatus_t)];
    char uart_msg_mode_ok[]  = "I2C mode sent\r\n";
    char uart_msg_seat_ok[]  = "I2C seat status sent\r\n";
    char errbuf[64];

    for(;;)
    {
        // Prepare mode frame
        mode_data[0] = 0x01; // Mode message ID
        mode_data[1] = (DefaultMode == AUTOMATIC_MODE) ? 'A' : 'M';

        // Prepare seat status frame
        SeatST.height   = (uint16_t)Height_Physical;
        SeatST.slide    = (uint16_t)Slide_Physical;
        SeatST.incline  = (uint16_t)Incline_Physical;
        SeatST.mode     = (DefaultMode == MANUAL_MODE) ? 'M' : 'A';
        SeatST.state    = (uint8_t)CurrentState;
        SeatST.checksum = Calculate_SeatChecksum(&SeatST);
        memcpy(txBuffer, &SeatST, sizeof(SeatST));

        if (osMutexAcquire(i2cMutexHandle, 500) == osOK)
        {
            // Send mode
            HAL_StatusTypeDef res_mode = HAL_I2C_Master_Transmit(&hi2c1,
                                                                 (I2C_SLAVE_ADD << 1),
                                                                 mode_data,
                                                                 2,
                                                                 500);

            if (res_mode == HAL_OK)
            {
                osMessageQueuePut(UartQueueHandle, uart_msg_mode_ok, 0, 10);
            }
            else
            {
                int len = snprintf(errbuf, sizeof(errbuf), "I2C mode error=%d\r\n", (int)res_mode);
                if(len > 0) osMessageQueuePut(UartQueueHandle, errbuf, 0, 10);
            }

            // Send seat status
            HAL_StatusTypeDef res_seat = HAL_I2C_Master_Transmit(&hi2c1,
                                                                 (I2C_SLAVE_ADD << 1),
                                                                 txBuffer,
                                                                 sizeof(txBuffer),
                                                                 500);

            if (res_seat == HAL_OK)
            {
                osMessageQueuePut(UartQueueHandle, uart_msg_seat_ok, 0, 10);
            }
            else
            {
                int len = snprintf(errbuf, sizeof(errbuf), "I2C seat error=%d\r\n", (int)res_seat);
                if(len > 0) osMessageQueuePut(UartQueueHandle, errbuf, 0, 10);
            }

            osMutexRelease(i2cMutexHandle);
        }

        // Also send via RTE API for demo/abstraction
        (void)Rte_Write_SeatControlReq((uint16_t)Height_Physical,
                                       (uint16_t)Slide_Physical,
                                       (uint16_t)Incline_Physical);

        osDelay(2000); // Send every 2 seconds
    }
}

// ========== FIXED ADC TASKS - READ IN BOTH MODES ==========
void AdcHeightTask(void *argument)
{
    char msg[60];

    for(;;)
    {
        uint32_t value = Read_ADC_Channel(ADC_CHANNEL_11);

        taskENTER_CRITICAL();
        Height_Variable = value;
        taskEXIT_CRITICAL();

        if(DefaultMode == MANUAL_MODE)
        {
            int len = snprintf(msg, sizeof(msg), "Height: raw=%lu, phys=%lu\r\n", value, Height_Physical);
            if (len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
        }

        osDelay(1000);
    }
}

void AdcSlideTask(void *argument)
{
    char msg[60];

    for(;;)
    {
        uint32_t value = Read_ADC_Channel(ADC_CHANNEL_12);

        taskENTER_CRITICAL();
        Slide_Variable = value;
        taskEXIT_CRITICAL();

        if(DefaultMode == MANUAL_MODE)
        {
            int len = snprintf(msg, sizeof(msg), "Slide: raw=%lu, phys=%lu\r\n", value, Slide_Physical);
            if (len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
        }

        osDelay(1200);
    }
}

void AdcInclineTask(void *argument)
{
    char msg[60];

    for(;;)
    {
        uint32_t value = Read_ADC_Channel(ADC_CHANNEL_13);

        taskENTER_CRITICAL();
        Incline_Variable = value;
        taskEXIT_CRITICAL();

        if(DefaultMode == MANUAL_MODE)
        {
            int len = snprintf(msg, sizeof(msg), "Incline: raw=%lu, phys=%lu\r\n", value, Incline_Physical);
            if (len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
        }

        osDelay(1300);
    }
}

// ========== FIXED PROFILE MANAGER ==========
void ProfileManager_Task(void *argument)
{
    char msg[100];
    static uint8_t save_btn_prev = 0, load_btn_prev = 0;
    uint8_t save_btn_current, load_btn_current;
    SeatProfile current_profile;
    HAL_StatusTypeDef result;

    osMessageQueuePut(UartQueueHandle, "ProfileManager Started\r\n", 0, 10);

    for(;;)
    {
        if(DefaultMode == AUTOMATIC_MODE)
        {
            // Save Profile - Blue button PA11
            save_btn_current = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_11);
            if(save_btn_current == GPIO_PIN_SET && save_btn_prev == GPIO_PIN_RESET)
            {
                // Create profile from current values
                current_profile.height = (uint16_t)Height_Variable;
                current_profile.slide = (uint16_t)Slide_Variable;
                current_profile.incline = (uint16_t)Incline_Variable;
                current_profile.checksum = Calculate_SeatProfileChecksum(&current_profile);

                // Save profile using inter-task communication (Profile ID 0)
                result = SaveProfile(0, &current_profile);

                if(result == HAL_OK)
                {
                    int len = snprintf(msg, sizeof(msg), "Profile Saved: H=%u S=%u I=%u\r\n",
                                      current_profile.height, current_profile.slide, current_profile.incline);
                    if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
                }
                else
                {
                    osMessageQueuePut(UartQueueHandle, "Profile Save Failed\r\n", 0, 10);
                }
            }
            save_btn_prev = save_btn_current;

            // Load Profile - User button PA10
            load_btn_current = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_10);
            if(load_btn_current == GPIO_PIN_SET && load_btn_prev == GPIO_PIN_RESET)
            {
                // Load profile using inter-task communication (Profile ID 0)
                result = LoadProfile(0, &current_profile);

                if(result == HAL_OK)
                {
                    // Apply loaded profile - set target values
                    taskENTER_CRITICAL();
                    Height_Variable = current_profile.height;
                    Slide_Variable = current_profile.slide;
                    Incline_Variable = current_profile.incline;
                    taskEXIT_CRITICAL();

                    int len = snprintf(msg, sizeof(msg), "Profile Loaded: H=%u S=%u I=%u\r\n",
                                      current_profile.height, current_profile.slide, current_profile.incline);
                    if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
                }
                else
                {
                    osMessageQueuePut(UartQueueHandle, "Profile Load Failed/Invalid\r\n", 0, 10);
                }
            }
            load_btn_prev = load_btn_current;
        }
        else
        {
            // Reset button states in manual mode
            save_btn_prev = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_11);
            load_btn_prev = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_10);
        }

        osDelay(500);
    }
}

// ========== SPI EEPROM TASK ==========
void SPI_EEPROM_Task(void *argument)
{
    char msg[80];
    EEPROM_Message_t message;
    HAL_StatusTypeDef result;

    osMessageQueuePut(UartQueueHandle, "SPI EEPROM Task Started\r\n", 0, 10);

    // Initialize CS pin
    HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);

    for(;;)
    {
        // Wait for messages from ProfileManager_Task
        if (osMessageQueueGet(EEPROMQueueHandle, &message, NULL, 100) == osOK)
        {
            uint16_t profile_address = PROFILE_BASE_ADDR + (message.profile_id * sizeof(SeatProfile));

            if (message.command == EEPROM_SAVE)
            {
                // Save profile to EEPROM
                result = HAL_OK;
                uint8_t *data_ptr = (uint8_t *)&message.profile_data;

                // Write profile data byte by byte
                for(int i = 0; i < sizeof(SeatProfile); i++)
                {
                    if(SPI_EEPROM_WriteByte(profile_address + i, data_ptr[i]) != HAL_OK)
                    {
                        result = HAL_ERROR;
                        break;
                    }
                    osDelay(10); // Write delay
                }

                // Send response back
                message.result = result;
                osMessageQueuePut(EEPROMQueueHandle, &message, 0, 100);

                // Log result
                if(result == HAL_OK)
                {
                    int len = snprintf(msg, sizeof(msg), "Profile %d saved to EEPROM\r\n", message.profile_id);
                    if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
                }
                else
                {
                    osMessageQueuePut(UartQueueHandle, "Profile save failed\r\n", 0, 10);
                }
            }
            else if (message.command == EEPROM_LOAD)
            {
                // Load profile from EEPROM
                result = HAL_OK;
                uint8_t *data_ptr = (uint8_t *)&message.profile_data;

                // Read profile data byte by byte
                for(int i = 0; i < sizeof(SeatProfile); i++)
                {
                    if(SPI_EEPROM_ReadByte(profile_address + i, &data_ptr[i]) != HAL_OK)
                    {
                        result = HAL_ERROR;
                        break;
                    }
                    osDelay(1);
                }

                // Send response back with loaded data
                message.result = result;
                osMessageQueuePut(EEPROMQueueHandle, &message, 0, 100);

                // Log result
                if(result == HAL_OK)
                {
                    int len = snprintf(msg, sizeof(msg), "Profile %d loaded from EEPROM\r\n", message.profile_id);
                    if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);
                }
                else
                {
                    osMessageQueuePut(UartQueueHandle, "Profile load failed\r\n", 0, 10);
                }
            }
        }

        osDelay(10); // Small delay to prevent busy waiting
    }
}

// ========== OTHER TASKS (SAME AS ORIGINAL) ==========
void SwitchModeTask(void *argument)
{
    char msg_auto[]   = "AUTO mode - Profile Save/Load active\r\n";
    char msg_manual[] = "MANUAL mode - ADC control active\r\n";

    for(;;)
    {
        if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET)
        {
            // Wait for button release to avoid multiple toggles
            osDelay(200);

            taskENTER_CRITICAL();
            DefaultMode = (DefaultMode == MANUAL_MODE) ? AUTOMATIC_MODE : MANUAL_MODE;
            taskEXIT_CRITICAL();

            if(DefaultMode == AUTOMATIC_MODE)
                osMessageQueuePut(UartQueueHandle, msg_auto, 0, 10);
            else
                osMessageQueuePut(UartQueueHandle, msg_manual, 0, 10);

            while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) {
                osDelay(10);
            }
        }
        osDelay(50);
    }
}

// Re-enable the button tasks for linker
void Buttons_ReadTask_highmode(void * argument)
{
    char msg1[] = "Height Increase\r\n";
    char msg2[] = "Slide Increase\r\n";
    char msg3[] = "Incline Increase\r\n";

    for(;;)
    {
        if(DefaultMode == MANUAL_MODE)
        {
            if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Height_Variable < 53) Height_Variable++;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg1, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Slide_Variable < 75) Slide_Variable++;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg2, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Incline_Variable < 1053) Incline_Variable++;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg3, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_7) == GPIO_PIN_SET) osDelay(10);
            }
        }
        osDelay(500);
    }
}

void Buttons_ReadTask_Lowmode(void * argument)
{
    char msg1[] = "Height Decrease\r\n";
    char msg2[] = "Slide Decrease\r\n";
    char msg3[] = "Incline Decrease\r\n";

    for(;;)
    {
        if (DefaultMode == MANUAL_MODE)
        {
            if(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_4) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Height_Variable > 20) Height_Variable--;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg1, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_4) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_5) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Slide_Variable > 30) Slide_Variable--;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg2, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_5) == GPIO_PIN_SET) osDelay(10);
            }
            else if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET)
            {
                taskENTER_CRITICAL();
                if(Incline_Variable > 675) Incline_Variable--;
                taskEXIT_CRITICAL();
                osMessageQueuePut(UartQueueHandle, msg3, 0, 10);
                while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_SET) osDelay(10);
            }
        }
        osDelay(500);
    }
}

void Calibration_Task(void *argument)
{
    char msg[100];

    osMessageQueuePut(UartQueueHandle, "Calibration Task Started\r\n", 0, 10);

    // Initialize default calibration
    CalibData.height_offset = 0;
    CalibData.height_coeff = 1000;
    CalibData.slide_offset = 0;
    CalibData.slide_coeff = 1000;
    CalibData.incline_offset = 0;
    CalibData.incline_coeff = 1000;
    CalibData.checksum = Calculate_Checksum(&CalibData);

    for(;;)
    {
        // Calculate physical values using calibration
        Calculate_Physical_Values();

        // Update RTE cache with current physicals
        Rte_Update_SeatHeight((uint16_t)Height_Physical);
        Rte_Update_SeatSlide((uint16_t)Slide_Physical);
        Rte_Update_SeatIncline((uint16_t)Incline_Physical);

        int len = snprintf(msg, sizeof(msg), "Calib: H_coeff=%u S_coeff=%u I_coeff=%u\r\n",
                          CalibData.height_coeff, CalibData.slide_coeff, CalibData.incline_coeff);
        if(len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);

        osDelay(10000); // Every 10 seconds
    }
}

/* USER CODE BEGIN Header_GearButton_Task */
/**
* @brief Function implementing the gearButtonTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_GearButton_Task */
void GearButton_Task(void *argument)
{
    /* USER CODE BEGIN GearButton_Task */
    // Initialize with the current button state to prevent false triggers on startup
    uint8_t previousButtonState = HAL_GPIO_ReadPin(GEAR_BUTTON_GPIO_Port, GEAR_BUTTON_Pin);

    // Send initial state message
    char init_msg[50];
    int init_len = snprintf(init_msg, sizeof(init_msg), "Gear button task started, initial state: %d\r\n", previousButtonState);
    if (init_len > 0) osMessageQueuePut(UartQueueHandle, init_msg, 0, 10);

    // Initial delay to stabilize
    osDelay(100);

    /* Infinite loop */
    for(;;)
    {
        // Read the current state of the gear button
        uint8_t currentButtonState = HAL_GPIO_ReadPin(GEAR_BUTTON_GPIO_Port, GEAR_BUTTON_Pin);

        // Detect button press (falling edge: button was released and is now pressed)
        if (currentButtonState == GPIO_PIN_RESET && previousButtonState == GPIO_PIN_SET)
        {
            // Debounce - wait and check again
            osDelay(20);
            if (HAL_GPIO_ReadPin(GEAR_BUTTON_GPIO_Port, GEAR_BUTTON_Pin) == GPIO_PIN_RESET)
            {
                // Set the flag to indicate button press
                GearButtonPressed = 1;

                // Debug message
                char msg[32];
                int len = snprintf(msg, sizeof(msg), "Gear button pressed\r\n");
                if (len > 0) osMessageQueuePut(UartQueueHandle, msg, 0, 10);

                // Wait for button release to prevent multiple triggers
                while (HAL_GPIO_ReadPin(GEAR_BUTTON_GPIO_Port, GEAR_BUTTON_Pin) == GPIO_PIN_RESET)
                {
                    osDelay(10);
                }
            }
        }

        // Update previous state
        previousButtonState = currentButtonState;

        // Task delay
        osDelay(50);
    }
    /* USER CODE END GearButton_Task */
}

void FSM_Task(void *argument)
{
    for(;;)
    {
        SeatState_t previous_state = CurrentState;

        // Check for gear button press to switch between Park and Drive
        if (GearButtonPressed == 1) {
            // Clear the flag immediately to prevent multiple triggers
            GearButtonPressed = 0;

            if (CurrentGear == GEAR_PARK) {
                CurrentGear = GEAR_DRIVE;
                CurrentState = STATE_DRIVING;
                osMessageQueuePut(UartQueueHandle, "Gear changed: P -> D\r\n", 0, 10);
            } else {
                CurrentGear = GEAR_PARK;
                CurrentState = STATE_IDLE;
                osMessageQueuePut(UartQueueHandle, "Gear changed: D -> P\r\n", 0, 10);
            }
            last_state_change = HAL_GetTick();
        }

        switch(CurrentState)
        {
            case STATE_OFF:
                ErrorLED_Off(); // Turn off error LED when system is off
                IdleLED_Off(); // Turn off idle LED when system is off
                MovingLED_Off(); // Turn off moving LED when system is off
                if(DefaultMode == AUTOMATIC_MODE || DefaultMode == MANUAL_MODE)
                {
                    CurrentState = STATE_IDLE;
                    osMessageQueuePut(UartQueueHandle, "FSM: OFF -> IDLE\r\n", 0, 10);
                }
                break;

            case STATE_IDLE:
                // Normal idle state
                IdleLED_On(); // Turn on idle LED
                ErrorLED_Off(); // Turn off error LED when in idle state
                MovingLED_Off(); // Turn off moving LED when in idle state
                if(Height_Physical != Height_Variable ||
                   Slide_Physical != Slide_Variable ||
                   Incline_Physical != Incline_Variable)
                {
                    CurrentState = STATE_MOVING;
                    osMessageQueuePut(UartQueueHandle, "FSM: IDLE -> MOVING\r\n", 0, 10);
                }
                break;

            case STATE_MOVING:
                // Check if reached target position
                MovingLED_On(); // Turn on moving LED
                IdleLED_Off(); // Turn off idle LED when moving
                ErrorLED_Off(); // Turn off error LED when moving
                if(abs(Height_Physical - Height_Variable) < 2 &&
                   abs(Slide_Physical - Slide_Variable) < 2 &&
                   abs(Incline_Physical - Incline_Variable) < 20)
                {
                    CurrentState = STATE_IDLE;
                    osMessageQueuePut(UartQueueHandle, "FSM: MOVING -> IDLE\r\n", 0, 10);
                }

                // Check for error conditions
                if(Height_Physical > 60 || Slide_Physical > 80 || Incline_Physical > 11000)
                {
                    CurrentState = STATE_ERROR;
                    osMessageQueuePut(UartQueueHandle, "FSM: MOVING -> ERROR\r\n", 0, 10);
                }
                break;

            case STATE_ERROR:
                // Stay in error until manual reset
                ErrorLED_On(); // Turn on error LED
                IdleLED_Off(); // Turn off idle LED when in error
                MovingLED_Off(); // Turn off moving LED when in error
                osMessageQueuePut(UartQueueHandle, "FSM: ERROR STATE\r\n", 0, 10);
                osDelay(1000);
                CurrentState = STATE_IDLE; // Auto recovery for demo
                break;

            case STATE_DRIVING:
                // Driving state - toggle LED on PA5 (LD2)
                HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin); // Toggle LED on PA5
                IdleLED_Off(); // Turn off idle LED when driving
                ErrorLED_Off(); // Turn off error LED when driving
                MovingLED_Off(); // Turn off moving LED when driving
                osMessageQueuePut(UartQueueHandle, "FSM: DRIVING STATE\r\n", 0, 10);
                osDelay(500); // Blink LED every 500ms
                break;

            default:
                CurrentState = STATE_OFF;
                break;
        }

        if(CurrentState != previous_state)
        {
            last_state_change = HAL_GetTick();
        }

        osDelay(100);
    }
}

uint32_t Read_ADC_Channel(uint32_t channel)
{
    ADC_ChannelConfTypeDef sConfig = {0};

    sConfig.Channel = channel;
    sConfig.Rank = 1;
    sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;

    HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    HAL_ADC_Start(&hadc1);
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
    uint32_t value = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);

    return value;
}

void Calculate_Physical_Values(void)
{
    // Apply calibration to convert raw values to physical values
    Height_Measured = (Height_Variable * CalibData.height_coeff) / 1000 + CalibData.height_offset;
    Slide_Measured = (Slide_Variable * CalibData.slide_coeff) / 1000 + CalibData.slide_offset;
    Incline_Measured = (Incline_Variable * CalibData.incline_coeff) / 1000 + CalibData.incline_offset;

    // Keep values within valid ranges (as per PDF spec)
    if(Height_Measured < 20) Height_Physical = 20;        // 2.0 cm minimum
    else if(Height_Measured > 53) Height_Physical = 53;   // 5.3 cm maximum
    else Height_Physical = Height_Measured;

    if(Slide_Measured < 30) Slide_Physical = 30;          // 3.0 cm minimum
    else if(Slide_Measured > 75) Slide_Physical = 75;     // 7.5 cm maximum
    else Slide_Physical = Slide_Measured;

    if(Incline_Measured < 6753) Incline_Physical = 6753;  // 67°5'30" minimum
    else if(Incline_Measured > 10553) Incline_Physical = 10553; // 105°5'30" maximum
    else Incline_Physical = Incline_Measured;
}

uint16_t Calculate_Checksum(Calibration_Data_t *data)
{
    uint16_t checksum = 0;
    // Treat the struct as a byte array and sum all bytes except the checksum field
    uint8_t *ptr = (uint8_t *)data;
    int count = sizeof(Calibration_Data_t) - sizeof(uint16_t);
    for(int i = 0; i < count; i++)
    {
        checksum += ptr[i];
    }

    return checksum;
}

uint16_t Calculate_ProfileChecksum(Profile_Data_t *p)
{
    return (p->height + p->slide + p->incline) & 0xFFFF;
}

uint16_t Calculate_SeatChecksum(SeatStatus_t *s)
{
    return (s->height + s->slide + s->incline + s->mode + s->state) & 0xFFFF;
}

uint16_t Calculate_SeatProfileChecksum(SeatProfile *p)
{
    return (p->height + p->slide + p->incline) & 0xFFFF;
}

HAL_StatusTypeDef SaveProfile(uint8_t profile_id, SeatProfile *p)
{
    if (p == NULL || profile_id >= 10) { // Support up to 10 profiles
        return HAL_ERROR;
    }

    // Calculate checksum for the profile
    p->checksum = Calculate_SeatProfileChecksum(p);

    // Create message for SPI_EEPROM_Task
    EEPROM_Message_t message;
    message.command = EEPROM_SAVE;
    message.profile_id = profile_id;
    message.profile_data.height = p->height;
    message.profile_data.slide = p->slide;
    message.profile_data.incline = p->incline;
    message.profile_data.checksum = p->checksum;
    message.result = HAL_OK;

    // Debug: start
    {
        char dbg[64];
        int len = snprintf(dbg, sizeof(dbg), "Saving Profile %u to EEPROM...\r\n", profile_id);
        if (len > 0) osMessageQueuePut(UartQueueHandle, dbg, 0, 10);
    }

    // Send message to SPI_EEPROM_Task
    if (osMessageQueuePut(EEPROMQueueHandle, &message, 0, 100) != osOK) {
        return HAL_ERROR;
    }

    // Wait for result (with timeout)
    EEPROM_Message_t response;
    uint32_t wait_deadline = HAL_GetTick() + 2000; // up to 2s to complete
    HAL_StatusTypeDef final_status = HAL_ERROR;
    do {
        if (osMessageQueueGet(EEPROMQueueHandle, &response, NULL, 250) == osOK) {
            if (response.command == EEPROM_SAVE && response.profile_id == profile_id) {
                final_status = (HAL_StatusTypeDef)response.result;
                break;
            }
            // Ignore unrelated messages
        }
    } while (HAL_GetTick() < wait_deadline);

    // Debug: end
    if (final_status == HAL_OK) {
        char dbg[48];
        int len = snprintf(dbg, sizeof(dbg), "Profile %u Saved OK\r\n", profile_id);
        if (len > 0) osMessageQueuePut(UartQueueHandle, dbg, 0, 10);
    } else {
        char dbg[48];
        int len = snprintf(dbg, sizeof(dbg), "Profile %u Save Failed\r\n", profile_id);
        if (len > 0) osMessageQueuePut(UartQueueHandle, dbg, 0, 10);
    }

    return final_status;
}

HAL_StatusTypeDef LoadProfile(uint8_t profile_id, SeatProfile *p)
{
    if (p == NULL || profile_id >= 10) { // Support up to 10 profiles
        return HAL_ERROR;
    }

    // Create message for SPI_EEPROM_Task
    EEPROM_Message_t message;
    message.command = EEPROM_LOAD;
    message.profile_id = profile_id;
    message.result = HAL_OK;

    // Debug: start
    {
        char dbg[64];
        int len = snprintf(dbg, sizeof(dbg), "Loading Profile %u from EEPROM...\r\n", profile_id);
        if (len > 0) osMessageQueuePut(UartQueueHandle, dbg, 0, 10);
    }

    // Send message to SPI_EEPROM_Task
    if (osMessageQueuePut(EEPROMQueueHandle, &message, 0, 100) != osOK) {
        return HAL_ERROR;
    }

    // Wait for result (with timeout)
    EEPROM_Message_t response;
    uint32_t wait_deadline = HAL_GetTick() + 2000; // up to 2s to complete
    HAL_StatusTypeDef final_status = HAL_ERROR;
    SeatProfile loaded = {0};
    do {
        if (osMessageQueueGet(EEPROMQueueHandle, &response, NULL, 250) == osOK) {
            if (response.command == EEPROM_LOAD && response.profile_id == profile_id) {
                if (response.result == HAL_OK) {
                    // Verify checksum
                    uint16_t calculated_checksum = Calculate_SeatProfileChecksum(&response.profile_data);
                    if (calculated_checksum == response.profile_data.checksum) {
                        loaded = response.profile_data;
                        final_status = HAL_OK;
                    } else {
                        final_status = HAL_ERROR;
                    }
                } else {
                    final_status = HAL_ERROR;
                }
                break;
            }
            // Ignore unrelated messages
        }
    } while (HAL_GetTick() < wait_deadline);

    if (final_status == HAL_OK) {
        p->height = loaded.height;
        p->slide = loaded.slide;
        p->incline = loaded.incline;
        p->checksum = loaded.checksum;
        char dbg[48];
        int len = snprintf(dbg, sizeof(dbg), "Profile %u Loaded OK\r\n", profile_id);
        if (len > 0) osMessageQueuePut(UartQueueHandle, dbg, 0, 10);
    } else {
        char dbg[48];
        int len = snprintf(dbg, sizeof(dbg), "Profile %u Load Failed\r\n", profile_id);
        if (len > 0) osMessageQueuePut(UartQueueHandle, dbg, 0, 10);
    }

    return final_status;
}
